err0     = "";
err1     = "Commentary is not finished. '*/' is expected.";
err2     = "Number overflow. Too big (or small) number.";
err3     = "Text string is not finished. \" or ' expected.";
err4     = "Internal error. Incorrect program of parsing automat.";
err5     = "This lexeme can not be used into current construction.";
err6     = "Empty text string.";
err7     = "Constant analysis. Too long constant.";
err1001  = "Expression analysis: Missing first argument for 'Take a slot' operator.";
err1003  = "Expression analysis: The operator name is expected.";
err1004  = "Expression analysis: Second argument of the operator is wrong.";
err1005  = "Expression analysis: Constant can not have slots.";
err1006  = "Expression analysis: It is impossible to create a tree by the current expression.";
err1007  = "Expression analysis: Internal error. Inaccessible action of the automat.";
err1008  = "Expression analysis: Internal error. Identifier is a variable name, but the original variable can not be found.";
err1009  = "Expression analysis: Secondary error - an operator name is expected.";
err1010  = "Expression analysis: The constant can not be created.";
err1011  = "Expression analysis: List of arguments for this function is expected.";
err1012  = "Expression analysis: Can not create operator with such arguments.";
err1013  = "Expression analysis: Secondary error - a variable name is expected.";
err1014  = "Expression analysis: Can't find variable with such name.";
err1015  = "Expression analysis: Can't get slot. May be: you try get slot not from a variable, incorrect name of the slot.";
err1016  = "Expression analysis: Arrays (and operator upon them) are not supported in the current version.";
err1017  = "Expression analysis: Internal error. Can't get argument for operator.";
err1018  = "Expression analysis: Operator with such arguments has not been found.";
err1019  = "Expression analysis: Internal error. Can't replace element in node list.";
err1020  = "Expression analysis: Internal error. Unreachable automat state.";
err1021  = "Expression analysis: Wrong lexeme.";
err1022  = "Expression analysis: Can't create indexing operator '[]'. May be: wrong type of index; secondary error; array is not define.";
err1023  = "Create generic descriptor: Incorrect parameter for the generic descriptor.";
err1024  = "Create generic descriptor: Can't create generic descriptor.";
err1025  = "Expression analysis: Wrong number of arguments for the operator of symbolic differentiation.";
err1026  = "Expression analysis: Can't get symbolic derivative.";
err1027  = "Expression analysis: 1-st argument of the operator of differentiation should be a function.";
err1028  = "Expression analysis: 2-nd argument of the operator of differentiation should be a variable.";
err1029  = "Expression analysis: Warning. Operator '=='(bool, bool) should be used instead '='(bool, bool) ('<==' instead '<=', '<<>>' instead '<>', etc.).";
err2001  = "Variables definition analysis: Variable name is expected.";
err2002  = "Variables definition analysis: ',' is expected.";
err2003  = "Variables definition analysis: Type name is expected.";
err2004  = "Variables definition analysis: ';' or 'with' are expected.";
err2005  = "Variables definition analysis: Internal error. Inaccessible action of the automat.";
err2006  = "Variables definition analysis: Such variable already exist.";
err2007  = "Variables definition analysis: Internal error. Variable can not be found again.";
err2008  = "Variables definition analysis: Can not get data type of this variable.";
err2009  = "Variables definition analysis: It isn't possible to create variable of such type.";
err2010  = "Variables definition analysis: Variables definition with 'with' keyword isn't supported in the current version.";
err2011  = "Variables definition analysis: Secondary error - a data type name is expected.";
err2012  = "Variables definition analysis: Secondary error - empty 'with' submodel.";
err2013  = "Variables definition analysis: Can't create 'with'-expression.";
err2014  = "Variables definition analysis: Can't add 'with'-expression for some variable(s).";
err2015  = "Variables definition analysis: ';' or 'with' are expected.";
err2020  = "Variables definition analysis: Internal error. Unreachable automat state.";
err2021  = "Variables definition analysis: Wrong lexeme.";
err3001  = "Submodel body analysis: IF-expression. 'then' is expected.";
err3002  = "Submodel body analysis: IF-expression. 'else' or 'end' are expected.";
err3003  = "Submodel body analysis: IF-expression. 'undef' or 'end' are expected.";
err3004  = "Submodel body analysis: IF-expression. 'end' is expected.";
err3005  = "Submodel body analysis: ALTERNATE-expression. 'or' or 'end' are expected.";
err3006  = "Submodel body analysis: Internal error. Inaccessible action of the automat.";
err3007  = "Submodel body analysis: The root of the tree should be boolean into IF- and ALTERNATE- expressions. Exchange operators: '=' <-> '==', '<' <-> '<<', '>=' <-> '>==', etc.";
err3008  = "Submodel body analysis: IF-expressions aren't supported in the current version.";
err3009  = "Submodel body analysis: There are not arguments for the ALTERNATE-expression.";
err3010  = "Submodel body analysis: Can not create ALTERNATE-expression. Module 'CATNemAbstractTypes' has not loaded or root of the tree isn't boolean.";
err3011  = "Submodel body analysis: FOR-expressions aren't supported in the current version.";
err3012  = "Submodel body analysis: ';' expected.";
err3013  = "Submodel body analysis: Warning. At the current version you can set a partial (weak) priority for constraint only.";
err3014  = "Submodel body analysis: Value is out of the range of partial (weak) priorities.";
err3015  = "Submodel body analysis: The condition of the IF-expression should have a boolean result.";
err3016  = "Submodel body analysis: Cannot get 'then'-part of the IF-expression.";
err3017  = "Submodel body analysis: Cannot get 'else'-part of the IF-expression.";
err3020  = "Submodel body analysis: Internal error. Unreachable automat state.";
err3021  = "Submodel body analysis: Wrong lexeme.";
err4001  = "Main parser: Name of the module is expected.";
err4002  = "Main parser: ';' is expected.";
err4003  = "Main parser: Internal error. Inaccessible action of the automat.";
err4004  = "Main parser: The module can not be loaded.";
err4005  = "Main parser: Data type definition isn't supported in the current version.";
err4006  = "Main parser: Constraint definition isn't supported in the current version.";
err4007  = "Main parser: Internal error. Main module name is not set.";
err4008  = "Main parser: The main module can not be created.";
err4009  = "Main parser: Secondary error - empty model.";
err4010  = "Main parser: This construction isn't supported in the current version.";
err4011  = "Main parser: The main module can not be saved.";
err4012  = "Main parser: Secondary error - Incorrect module name.";
err4013  = "Main parser: Only one main model can exist into module.";
err4020  = "Main parser: Internal error. Unreachable automat state.";
err4021  = "Main parser: Wrong lexeme.";
err5001  = "Main compiler class: Secondary error. Can't build MAIN-parser -> Can't create solver -> Can't create network...";
err5002  = "Main compiler class: Can't create network.";
err5003  = "Main compiler class: Secondary error. Can't create solver -> Can't create network.";
err5004  = "Main compiler class: The machinery of variable value setting isn't implemented in the current version.";
err5005  = "Main compiler class: Run failed.";
err5006  = "Main compiler class: Can't save module.";
err5007  = "Main compiler class: Cannot get number of solutions.";
err5008  = "Main compiler class: Cannot load module. ";
err5009  = "Main compiler class: Cannot load network data.";
err5010  = "Main compiler class: Cannot save network data.";
err5011  = "Main compiler class: Internal error. Cannot create StringCollection.";
err6001  = "List of arguments: Name of an argument expected.";
err6002  = "List of arguments: ',' or ':' expected.";
err6003  = "List of arguments: Wrong data type of the argument.";
err6004  = "List of arguments: ';' or ')' expected.";
err6005  = "List of arguments: Internal error. Inaccessible action of the automat.";
err6006  = "List of arguments: Argument with such name already exist.";
err6007  = "List of arguments: It isn't possible to create argument of such type.";
err6008  = "List of arguments: List of arguments expected.";
err6020  = "List of arguments: Internal error. Unreachable automat state.";
err6021  = "List of arguments: Wrong lexeme.";
err7001  = "Class definition analysis: Internal error. 'class' expected.";
err7002  = "Class definition analysis: Class name is expected.";
err7003  = "Class definition analysis: Expected lexemes: ':'- for list of base class\es; '('- for list of parameters; ';'- in other case.";
err7004  = "Class definition analysis: ':' or ';' expected.";
err7005  = "Class definition analysis: Name of base class is expected.";
err7006  = "Class definition analysis: ',' expected.";
err7007  = "Class definition analysis: Internal error. 'slot' expected.";
err7008  = "Class definition analysis: 'end' expected.";
err7009  = "Class definition analysis: Internal error. Inaccessible action of the automat.";
err7010  = "Class definition analysis: You Can't redefine instrumental class in the current version.";
err7011  = "Class definition analysis: You Can't create abstract classes in the current version.";
err7012  = "Class definition analysis: The definitions of abstract and generic classes are not supported in the current version.";
err7013  = "Class definition analysis: Multiway inheritance isn't supported in the current version.";
err7014  = "Class definition analysis: Wrong base class for inheritance.";
err7015  = "Class definition analysis: Arrays are not supported in the current version.";
err7016  = "Class definition analysis: Can't create class. It's possible: secondary error; non-structured base class; incorrect set of the slots; etc.";
err7020  = "Class definition analysis: Internal error. Unreachable automat state.";
err7021  = "Class definition analysis: Wrong lexeme.";
err8001  = "Array definition: Internal error. 'array' - expected.";
err8002  = "Array definition: Expected size of array (into '[..]').";
err8003  = "Array definition: ']' expected.";
err8004  = "Array definition: 'of' expected.";
err8005  = "Array definition: Can't get type of the array element.";
err8006  = "Array definition: ';' expected.";
err8007  = "Array & set definition: This version does not support definitions of set classes.";
err8008  = "Array definition: Dynamic arrays are not supported in the current version.";
err8009  = "Array definition: Internal error. Inaccessible action of the automat.";
err8010  = "Array definition: You can create only 1- or 2- dimension array in the current version.";
err8011  = "Array definition: Size of array should be integer.";
err8012  = "Array definition: Size of array should be greater then 0.";
err8013  = "Array definition: Can't create array. It's possible: secondary error; incorrect element class; too big size of the array; module 'CATNemArrays' or 'CATNemAbstractTypes' has not loaded; etc.";
err8014  = "Array definition: Wrong array type. Can't create variable of such type.";
err8015  = "Array definition: Module 'CATNemEnumIntegers' was not loaded.";
err8016  = "Array definition: Wrong array element type. Can't create variable of such type.";
err8017  = "Array definition: Error occurs during creation of auxiliary constraints.";
err8018  = "Array definition: Can't create indexing operator '[]' for the array. ";
err8020  = "Array definition: Internal error. Unreachable automat state.";
err8021  = "Array definition: Wrong lexeme.";
err9001  = "Constraint definition analysis: Internal error. One of following keywords are expected: 'function' or 'operator' or 'prefix' or 'method'.";
err9002  = "Constraint definition analysis: Incorrect constraint name.";
err9003  = "Constraint definition analysis: List of argument - '( ... )' - expected. May be, incorrect operator name.";
err9004  = "Constraint definition analysis: ':' (class of Result of the constraint) expected.";
err9005  = "Constraint definition analysis: Type of result of the constraint expected.";
err9006  = "Constraint definition analysis: ';' or ':' expected.";
err9007  = "Constraint definition analysis: Parameter for generic constraint should be a constant string.";
err9008  = "Constraint definition analysis: ';' or ',' expected.";
err9009  = "Constraint definition analysis: Secondary error. 'end' expected.";
err9010  = "Constraint definition analysis: The current version does not supported definition of class methods.";
err9011  = "Constraint definition analysis: Internal error. Inaccessible action of the automat.";
err9012  = "Constraint definition analysis: Incorrect type of result of this constraint. ";
err9013  = "Constraint definition analysis: The current version doesn't supported generic constraints.";
err9014  = "Constraint definition analysis: Can not create constraint.";
err9015  = "Constraint definition analysis: Incorrect operator parameter.";
err9016  = "Constraint definition analysis: First parameter should be 'table'. Only this type of generic constraints is supported into the current version.";
err9017  = "Constraint definition analysis: There can be not more then 2 arguments.";
err9018  = "Constraint definition analysis: Incorrect basis type of the method.";
err9019  = "Constraint definition analysis: Incorrect name of the method. The name of a method should be represented as 'TypeName::MethodName'.";
err9020  = "Constraint definition analysis: Internal error. Unreachable automat state.";
err9021  = "Constraint definition analysis: Wrong lexeme.";
err10001 = "Compiler parameters: In the current version you can used 'eps' and 'solutions' parameters only.";
err10002 = "Compiler parameters: '=' expected.";
err10003 = "Compiler parameters: Incorrect value of the parameter.";
err10004 = "Compiler parameters: ';' expected.";
err10005 = "Compiler parameters: Internal error. Inaccessible action of the automat.";
err10006 = "Compiler parameters: Constant value or '?' are expected.";
err10007 = "Compiler parameters: Incorrect name of the variable.";
err10008 = "Compiler parameters: This parameter should be set as 'On' or 'Off'.";
err10009 = "Compiler parameters: Incorrect name of partial constraint strategy. Correct names: 'LocalPredicate', 'LocalError', 'GlobalPredicate', 'WorstCase', 'LeastSquares', 'LocalError2'";
err10020 = "Compiler parameters: Internal error. Unreachable automat state.";
err10021 = "Compiler parameters: Wrong lexeme.";
err11001 = "Preprocessor: Keyword 'define' is expected.";
err11002 = "Preprocessor: Name of the macro substitution expected.";
err11003 = "Preprocessor: Here should be list of arguments, or '=', or '\n'.";
err11004 = "Preprocessor: Incorrect name of argument.";
err11005 = "Preprocessor: ',' or ')' expected.";
err11006 = "Preprocessor: Internal error. Wrong lexeme into body of the macro substitution.";
err11020 = "Preprocessor: Internal error. Unreachable automat state.";
err11021 = "Preprocessor: Wrong lexeme.";
err11022 = "Preprocessor: Internal error. Inaccessible action of the automat.";
err11023 = "Preprocessor: The substitution can not be implemented.";
err11024 = "Preprocessor: Such macro substitution already exist.";
err11025 = "Preprocessor: The substitution can not be removed.";
err11026 = "Preprocessor: The substitution does not exist.";
err11027 = "Preprocessor: List of parameters for the substitution is expected.";
err11028 = "Preprocessor: '@forall' without '@end'.";
err11029 = "Preprocessor: '@end' without '@forall'.";
err11031 = "Preprocessor: Internal error. '@forall' expected. ";
err11032 = "Preprocessor: Name of the iterating variable is expected.";
err11033 = "Preprocessor: '=' expected.";
err11034 = "Preprocessor: Wrong iteration bounds. The bounds for indexing variable should be set as an 'interval int' constant.";
err11035 = "Preprocessor: ';' expected.";
err11036 = "Preprocessor: Incorrect name of the including file.";
err11037 = "Preprocessor: Cannot open include-file or empty file.";
err12001 = "Table parser: Keywords 'uses', 'table' or 'module' are expected.";
err12002 = "Table parser: Incorrect name of the loading module.";
err12003 = "Table parser: ';' expected.";
err12004 = "Table parser: Module name is expected.";
err12005 = "Table parser: '{' expected.";
err12006 = "Module description: Operator descriptions or output path are expected.";
err12007 = "Table parser: Internal error. Unreachable automat state.";
err12008 = "Table parser: Cannot load module.";
err12009 = "Table parser: Wrong name of the module.";
err12010 = "Table parser: Cannot save module.";
err12011 = "Table parser: Path for the module save is redefined.";
err12020 = "Table parser: Internal error. Unreachable automat state.";
err12021 = "Table parser: Wrong lexeme.";
err12030 = "'=' expected.";
err12031 = "Wrong path. Path should be set as 'path' or as %ENVIRONMENT_VAR.";
err13001 = "Table description: Internal error. 'table' expected.";
err13002 = "Table description: Name of the table should be a string or an identifier.";
err13003 = "Table description: Arguments definition is missed.";
err13004 = "Table description: '{' expected.";
err13005 = "Table description: Keywords 'source', 'table', 'SQL', 'path' and 'format' only can be used for description of tables.";
err13006 = "Table description: ';' expected.";
err13007 = "Table description: Additional parameters (SQL request) should be represented as string.";
err13008 = "Table description: Incorrect table format. 'text', 'binary', 'memory' or 'relational' expected.";
err13009 = "Table description: Index should be set as a name of the table argument or as a number of the table column.";
err13010 = "Table description: '=', 'path', 'format', 'SQL' expected.";
err13011 = "Table description: To indicate source of data you should set filename (as string) or concrete datas (as constants enclosed in braces).";
err13012 = "Table description: Internal error. Unreachable automat state.";
err13013 = "Table description: '=' expected.";
err13014 = "Table description: The table (or a table with same name) already exists.";
err13015 = "Table description: Redefine data source.";
err13016 = "Table description: Incorrect file name for data source.";
err13017 = "Table description: In the case then the source datas are set directly, the source format should be 'text'.";
err13018 = "Table description: Direct source data should be a constant. ";
err13019 = "Table description: Direct source data should be separated by a comma.";
err13020 = "Table description: Internal error. Unreachable automat state.";
err13021 = "Table description: Wrong lexeme.";
err13022 = "Table description: Index redefined.";
err13023 = "Table description: Incorrect index value.";
err13024 = "Table description: Index definition. Unknown argument name.";
err13025 = "Table description: Double use of 'source' keyword.";
err13026 = "Table description: Table format or source format are not defined.";
err13027 = "Warning: Keyword 'SQL' is significant only if format is 'relational'.";
err13028 = "Table description: Cannot create resulting table.";
err13029 = "Table description: Cannot load source table.";
err13030 = "Table description: Cannot load source text file.";
err13031 = "Table description: Cannot save resulting table.";
err13032 = "Table description: Cannot get a row from the source table. ";
err13033 = "Table description: Incorrect value of an element of the table. ";
err13034 = "Table description: Contradiction or incorrect value into an element of the table. ";
err13035 = "Warning: An element of the table has value 'Any'. ";
err13036 = "Table description: Format redefined.";
err13037 = "Table description: Internal error. Unknown format.";
err13038 = "Table description: Default output stream isn't defined.";
err14001 = "Operator description: Internal error. Keyword 'operator' expected.";
err14002 = "Operator description: Name of the operator should be a string or an identifier.";
err14003 = "Operator description: Arguments definition is missed.";
err14004 = "Operator description: '{' expected.";
err14005 = "Operator description: Keywords 'source', 'format' and 'path' only can be used for description of operators.";
err14006 = "Operator description: '=' expected.";
err14007 = "Operator description: Name of the causing table should be a string or an identifier.";
err14008 = "Operator description: ';' expected.";
err14009 = "Operator description: Internal error. Inaccessible action of the automat.";
err14010 = "Operator description: Name of the table is redefined.";
err14011 = "Operator description: Incorrect name of the operator or the causing table.";
err14012 = "Operator description: Wrong operator arguments.";
err14013 = "Warning: Redefine path for an existing table.";
err14014 = "Operator description: Cannot create operator by the table.";
err14015 = "Operator description: Wrong source format. You can use only 'binary' or 'relational' formats.";
err14016 = "Operator description: Source format is redefined.";
err14017 = "Operator description: Internal error. Cannot get column type from the table.";
err14020 = "Operator description: Internal error. Unreachable automat state.";
err14021 = "Operator description: Wrong lexeme.";
err15001 = "Warning: Cannot set initial values.";
err15002 = "Warning: Cannot set desired values.";
err15003 = "Warning: Cannot set enumerated values."; 
