DYNKernelLog_Default_Fallback.Request="消息";
DYNKernelLog_Default_Fallback.Diagnostic="/P1";

DYNKernelLogCheck.Request="檢查 /P1";

DYNDebug1.Request="/P1";
DYNDebug2.Request="  /P1";
DYNDebug3.Request="方程式";
DYNDebug3.Diagnostic="/P1";
DYNSemiLinearFailed.Request="無法支持使用半線性。";
DYNFailedInlineIntegration.Request="無法為內聯集成生成代碼。";
DYNFailedInlineIntegration.Diagnostic="問題可能為奇點。\n請勿平移內聯集成以確保更好的診斷。";
DYNKernelLogMessage_0289.Request="/P1 模擬方程式系統。";
DYNFailedCodegenUnknownEquType.Request="無法為方程式生成代碼";
DYNFailedCodegenUnknownEquType.Diagnostic="/P1";
DYNFailedCodeGenUnexpandedBlock.Request="當前版本無法為在方程式中涉及未展開的 for/if 子句的代數環生成代碼。";
DYNFailedCodeGenUnexpandedBlock.Diagnostic="未知量：\n/P1\n方程式：\n/P2";
DYNFailedCodeGenForAlgLoopWhen.Request="無法為";
DYNFailedCodeGenForAlgLoopWhen.Diagnostic="涉及 when 方程式或算法和 when 零件的代數環生成代碼。\n未知量：\n/P1\n方程式：\n/P2";
DYNFailedCodeGenForAlgLoopWhen1.Request="您可以切斷環， ";
DYNFailedCodeGenForAlgLoopWhen1.Diagnostic="方法是將 \"pre\" 放置在\nwhen 零件或 when 條件中未知連續時間變量的一些參考周圍。";
DYNAlgLoopInvolvingConstants.Request="無法為涉及常量的此代數環生成代碼。";
DYNAlgLoopInvolvingConstants.Diagnostic="未知量：\n/P1\n方程式：\n/P2";
DYNFailedCodeGenBoolWHintLoopA.Request="無法為涉及布爾值的代數環生成代碼。";
DYNFailedCodeGenBoolWHintLoopA.Diagnostic="未知量：\n/P1\n",
"模型包括以下提示：\n/P2";
DYNFailedCodeGenIntegerBoolLoop.Request="當前版本無法為涉及整數或布爾值的代數環生成代碼。";
DYNFailedCodeGenIntegerBoolLoop.Diagnostic="未知量：\n/P1\n方程式：\n/P2";
DYNFailedCodeGenIndexReduction.Request="無法生成與索引減少相關的代碼。";
DYNFailedSolveRealSystem.Request="無法求解方程式的實系統。";
DYNFailedSolveRealSystem.Diagnostic="未知量：\n/P1\n方程式：\n/P2";
DYNFailedSolveRealSystemA.Request="系統為奇點，這可能是因冗余初始條件所致。";
DYNFailedSolveRealSystemB.Request="系統為奇點，這可能是因未檢測到的高 DAE 索引所致。";
DYNFailedCodeGenOccured.Request="為代數環生成代碼時，未能生成代碼。";
DYNBadWhenCausality.Request="計算因果關系分析需要變量";
DYNBadWhenCausality.Diagnostic="  /P1\n將從方程式中求解：\n  /P2\n但這會與 when 方程式的語義發生矛盾。";
DYNBadWhenCausalityLoop.Request="計算因果關系分析需要變量";
DYNBadWhenCausalityLoop.Diagnostic="  /P1\n將從方程式中求解：\n  /P2\n不過，when 條件還取決于未知量。";
DYNBadWhenCausalityLoop1.Request="將 'pre' 放置在 when 條件中的這些參考周圍，即可切斷環。";
DYNInlineIntegrationMixedAlgWhen.Request="內聯集成無法處理 when 與 non-when 相混合的算法。";
DYNInlineIntegrationBadCrossingFunction.Request="無法生成與內聯集成中交叉函數相關的代碼。";
DYNFailedCodeGenForInlinedIntAlgLoopWhen.Request="無法為內聯集成生成代碼。";
DYNFailedCodeGenForInlinedIntAlgLoopWhenA.Request="內聯集成引入代數環，且方程式";
DYNFailedCodeGenForInlinedIntAlgLoopWhenA.Diagnostic="具有繼續時間和 when 元素：\n/P1";
DYNFailedCodeGenForInlinedIntAlgLoopWhenB.Request="分割方程式或算法即可切斷環。";
DYNKernelLogMessage_0294.Request="nblocks1A = /P1";
DYNKernelLogMessage_0295.Request="nblocks1A = /P1";
DYNKernelLogMessage_0296.Request="顯示 ders = /P1";
DYNKernelLogMessage_0297.Request="Remunknowns = /P1";
DYNKernelLogMessage_0031.Request="/P1";
DYNKernelLogMessage_0031.Diagnostic="/P2\n";
DYNKernelLogMessageInvalidXMLDocument.Request="XML 文檔無效，原因是";
DYNKernelLogMessageInvalidXMLDocument.Diagnostic="/P1\n";
DYNKernelLogMessageLoadingMSXML.Request="加載 MSXML 時出錯：/P1";
DYNKernelLogMessage_0031InvalidParameter.Request="無效的參數 /P1";
DYNKernelLogMessage_0031FailedToSetParameter.Request="未能設置參數 /P1";
DYNKernelLogMessage_0031ErrorCreating.Request="創建時出錯：/P1";
DYNKernelLogMessage_0031FailedXslTransformation.Request="xsl 變換失敗：/P1";
DYNEquationNumberBad.Request="無法排序方程式。";
DYNFailedToHandleLoopWArrayEqu.Request="無法處理含數組方程式的代數環。";
DYNContactDynasim.Request="請與支持人員聯系。";
DYNKernelLogError_0042.Request="Dymola 中發生與方程式系統中多重返回函數相關的內部錯誤。";
DYNInconsistentEquation.Request="不一致的方程式";
DYNRemovedAdditionalEqu.Request="移除其他一致的方程式";
DYNInconsistentEqu.Request="不一致的方程式";
DYNAdditionaLog1.Request="模型指定";
DYNAdditionaLog1.Diagnostic="  /P1 = /P2\n  /P3 = /P4";
DYNAdditionaLog2.Request="不過，模型也會明確或間接指定";
DYNAdditionaLog2.Diagnostic="  /P1 = /P2/P3";
DYNCircularEqualities.Request="檢測到圓等式。";
DYNCircularEqualities1.Request="方程式 ";
DYNEquation.Request="/P1";
DYNEquationDerivedFrom.Request="  派生自";
DYNEquationDerivedFrom.Diagnostic="/P1";
DYNCircularEqualities2.Request="指以下變量的圓等式：";
DYNCircularEqualities2.Diagnostic="/P1";
DYNModelHint.Request="模型包括以下提示";
DYNModelHint.Diagnostic="/P1";
DYNSkippingStartVal.Request="跳過 /P1 = /P2 的起始值";
DYNSkippingStartVal.Diagnostic="并使用 /P3 = /P4";
DYNKernelLogMessage_0298.Request="/P1 簡易方程式已消除。";
DYNAutomatonHandlerFailedTransition.Request="無法處理轉換";
DYNAutomatonHandlerFailedTransition.Diagnostic=" /P1";
DYNTransitionStateInWrongScope.Request="轉換時發生狀態參數不正確的錯誤";
DYNTransitionStateInWrongScope.Diagnostic=" /P1 出現在部件 /P2 中。";
DYNTransitionStateInWrongScope1.Request="參數 /P1 并非此部件內的部件。";
DYNInitStateInWrongScope.Request="initState 中發生狀態參數不正確的錯誤";
DYNInitStateInWrongScope.Diagnostic=" /P1 出現在部件 /P2 中。";
DYNInitStateInWrongScope1.Request="參數 /P1 并非此部件內的部件。";
DYNMissingInitState.Request="缺少自動化的初始狀態，包括狀態";
DYNMissingInitState1.Request="  /P1";
DYNMultipleDifferentInitState.Request="自動化的多個初始狀態，包括狀態";
DYNMultipleDifferentInitState1.Request="  /P1";
DYNMultipleDifferentInitState2.Request="以下狀態標記為初始狀態。";
DYNMultipleDifferentInitState3.Request="  /P1";
DYNMultipleInitState.Request="狀態 /P1 具有作為初始狀態的多個標記。";
DYNMultipleInitState1.Request="它是自動化的一部分，包括狀態";
DYNMultipleInitState2.Request="  /P1";
DYNSynchronousArgNonPos.Request="/P2 的參數 /P1";
DYNSynchronousArgNonPos.Diagnostic="在方程式\n/P3\n中必須為正值。";
DYNFailedSynchClockMixed.Request="連接時間零件和離散零件不會分解。";
DYNHoldArg1NonVar.Request="當前支持需要 /P2 的參數 /P1";
DYNHoldArg1NonVar.Diagnostic="在方程式\n/P3\n中為簡單變量參考。";
DYNMixedAlgorithm3.2.Request="塊 /P1 為混合算法和 when，這是不允許的。";
DYNMixedDerWhen3.2.Request="塊 /P1 含有計算導數的 when 方程式，這是不允許的。";
DYNMixedContinuousDiscreteUse3.2.Request="塊 /P1 含有連續時間和離散時間零件中需要的連續時間方程式，這過于復雜，以致于不會自動轉換。";
DYNWhenEqusUse3.2.Request="塊 /P1 含有 when 方程式，因此屬于離散時間。";
DYNIsDeducedAsDiscreteTime3.2.Request="塊 /P1 需要屬于離散時間，且能夠推導成為離散時間。";
DYNDerUnknowns3.2.Request="塊 /P1 可計算導數，但不需要作為離散時間零件，而保留為連續時間零件。";
DYNRestrictingToDiscreteTimeUse3.2.Request="塊 /P1 為連續時間，但為離散時間零件所需項。而保留為連續時間零件。最好限于離散時間計算，因為其他連續時間計算與它們無關。";
DYNIsDeducedAsDiscreteTimeButKeptContinuousTime3.2.Request="塊 /P1 可以推導為離散時間，但能夠保留為連續時間。";
DYNUnknowns3.2.Request="/P1 /P2";
DYNsampleVars3.2.Request="取樣的變量";
DYNsampleVars3.2.Diagnostic="/P1";
DYNholdVars3.2.Request="保留的變量";
DYNholdVars3.2.Diagnostic="/P1";
DYNCondConstraint.Request="轉換條件約束的結果";
DYNCondConstraintA.Request="尚未處理";
DYNCondConstraintA.Diagnostic="/P1";
DYNCondConstraintX.Request="第一個約束為非冗余";
DYNCondConstraintX.Diagnostic="/P1";
DYNCondConstraintB.Request="第一個約束為冗余且已滿足";
DYNCondConstraintB.Diagnostic="/P1";
DYNCondConstraintC.Request="第一個約束為冗余但未滿足";
DYNCondConstraintC.Diagnostic="/P1";
DYNCondConstraintD.Request="第一個約束為冗余，便未確定是否已滿足";
DYNCondConstraintD.Diagnostic="/P1";
DYNCondConstraintE.Request="將決定在模擬過程中自動使用";
DYNCondConstraintE.Diagnostic="/P1";
DYNCondConstraintBadCondVar.Request="條件約束的第一個參數需要是簡單變量參考";
DYNCondConstraintBadCondVar.Diagnostic="/P1";
DYNCondConstraintFailure.Request="處理失敗";
DYNCondConstraintFailure.Diagnostic="/P1";
DYNCondConstraintError.Request="第一個約束為冗余但未滿足";
DYNCondConstraintError.Diagnostic="/P1";
DYNKernelLogWarning_0006d.Request="有條件啟用的物理連接器的默認連接。";
DYNKernelLogWarning_0006d.Diagnostic="",
"這通常表示缺少連接，或連接本不應啟用：/P1\n";
DYNEncryptedConnectorBad.Request="加密的連接器出現錯誤。";
DYNConnectingInsideInputTwiceBad.Request="輸入變量 /P1 作為內部連接器（=子模型中的連接器）的部件出現兩次。";
DYNConnectingOutsideInputTwiceBad.Request="輸入變量 /P1 作為外部連接器（=此模型中的連接器）的部件出現兩次。";
DYNConnectingInsideOutputTwiceBad.Request="輸出變量 /P1 作為內部連接器（=子模型中的連接器）的部件出現兩次。";
DYNConnectingOutsideOutputTwiceBad.Request="輸出變量 /P1 作為外部連接器（=此模型中的連接器）的部件出現兩次。";
DYNConnectingInputOutputTwiceBad1.Request="上一次出現為";
DYNConnectingInputOutputTwiceBad2.Request="第二次出現為";
DYNConnSimpleVarToConnExp.Request="對于可擴展連接器";
DYNConnSimpleVarToConnExp.Diagnostic=" 連接簡單變量 /P1 和連接器變量 /P2。";
DYNConnDimMismatch.Request="/P1 和 /P2 的尺寸不匹配。";
DYNConnectIncompatibleComponentsExp.Request="對于可擴展連接器";
DYNConnectIncompatibleComponentsExp.Diagnostic=" 不兼容的 /P1 和 /P2";
DYNConnDimMismatchExp.Request="對于可擴展連接器";
DYNConnDimMismatchExp.Diagnostic=" /P1 和 /P2 的尺寸不匹配。";
DYNKernelLogError_0043.Request="總線連接處理似乎已進入循環。";
DYNInsideBusNonBusBad.Request="內部總線：連接總線 /P1 和非總線 /P2";
DYNKernelLogWarning_Connect1.Request="為變量添加零方程式";
DYNKernelLogWarning_Connect1.Diagnostic="/P1";
DYNKernelLogWarning_0006a.Request="警告：連接集中的類型（Real 和非 Real 類型）存在沖突";
DYNKernelLogWarning_0006a.Diagnostic=" ";
DYNKernelLogWarning_0006.Request="多個輸出";
DYNKernelLogWarning_0006.Diagnostic="在連接集中生成相同信號：\n /P1";
DYNKernelLogWarning_0004.Request="警告：總線輸入 /P1 與連接集中的多個頂級連接器匹配。";
DYNKernelLogWarning_0005.Request="總線輸入 /P1 在連接集中缺少匹配的非輸入。";
DYNKernelLogMessage_0057.Request="列出可擴展連接器的內容。";
DYNKernelLogMessage_0057.Diagnostic="",
"單元具有下列變量：/P1。";
DYNKernelLogWarning_0005xx.Request="警告：變量 /P1 通過屬性 /P2 進行聲明，但推導出的屬性為 /P3";
DYNKernelLogError_0044.Request="錯誤：連接的大小不匹配。";
DYNKernelLogError_0044.Diagnostic="",
"  由于存在與 /P1 元素的連接，我們必須擴展 /P2（它將與之連接）。\n",
" 這些數組的大小不匹配。\n";
DYNKernelLogMessage_0061.Request="  注意：由于存在與 /P1 元素的連接，我們必須擴展 /P2（它將與之連接）。";
DYNKernelLogWarning_0007.Request="警告：在連接集中找到作為內部和外部連接器的 /P1！";
DYNKernelLogWarning_0007.Diagnostic="",
"這將意味著欠定方程式集。\n";
DYNKernelLogWarning_0008.Request="警告：在連接集中找到作為內部和外部連接器的 /P1！";
DYNKernelLogWarning_0008.Diagnostic="",
"這將意味著冗余方程式。\n";
DYNNonMatchingUnits.Request="/P1 的單位為 /P2，而 /P3 的單位為 /P4。";
DYNIndirectlyConnectedVars.Request="變量將間接連接。";
DYNNonMatchingQuantities.Request="/P1 的數量為 /P2，而 /P3 的數量為 /P4。";
DYNKernelLogError_0045.Request="內部錯誤，請報告給支持部門：參數數組展開失敗。";
DYNKernelLogMessage_0062.Request="跳過變量 /P1 的默認連接器。";
DYNKernelLogWarning_0009.Request="警告：Dymola 兼容模式禁止";
DYNKernelLogWarning_0009.Diagnostic=" /P1,\n",
" 的默認連接池，原因是它存在外部參考。\n";
DYNKernelLogMessage_0063.Request="  /P1 = 0（未連接）";
DYNKernelLogMessage_0064.Request=" /P1 /P2";
DYNKernelLogMessage_0065.Request="+/- ConcealedVariable ";
DYNKernelLogMessage_0066.Request=" = 0";
DYNKernelLogWarning_0010A.Request="在同一連接集中存在多個原因信號來源。";
DYNKernelLogWarning_0010A.Diagnostic=" /P1 ";
DYNKernelLogWarning_0011A.Request="在同一連接集中存在一個（或多個）沒有任何來源的原因信號。";
DYNKernelLogWarning_0011A.Diagnostic=" /P1 ";
DYNKernelLogMessage_0069.Request="/P1";
DYNVarDeclLoc.Request="變量 /P1 聲明位置為 ";
DYNInMultipleAssNode.Request="在 /P1 中";
DYNConnectUnmatchedDimA.Request="/P1 中的尺寸不匹配";
DYNConnectUnmatchedDimA.Diagnostic="",
"第一個參數 /P2 是具有 /P3 尺寸\n的連接器，而第二個參數 /P4 是具有 /P5 尺寸的連接器。";
DYNConnectUnmatchedSizesA.Request="/P1 中的大小不匹配";
DYNConnectUnmatchedSizesA.Diagnostic="",
"第一個參數 /P2 是大小為 /P3\n的連接器，而第二個參數 /P4 是大小為 /P5 的連接器。";
DYNConnectUnmatchedDim.Request="/P1 中的尺寸不匹配";
DYNConnectMissingElement.Request="缺少 /P1 下標的元素";
DYNConnectMissingElementVar.Request="缺少元素變量 /P1";
DYNConnectUnmatchedDimB.Request="/P1 中的尺寸不匹配";
DYNConnectUnmatchedDimB.Diagnostic="",
"未知問題，或由于存在問題導致展開。\n",
"連接的變量必須具有可展開成文字的下標。";
DYNConnectUnmatchedSizes.Request="/P1 中的大小不匹配";
DYNConnectUnmatchedSizes.Diagnostic="",
"第一個參數 /P2 是大小為 /P3\n的連接器，而第二個參數 /P4 是大小為 /P5 的連接器。";
DYNConnectUnmatchedDimC.Request="/P1 中的尺寸不匹配";
DYNConnectUnmatchedDimC.Diagnostic="",
"未知問題，或由于存在問題導致展開。";
DYNExpandableConnBad.Request="無法在使用";
DYNExpandableConnBad.Diagnostic="一個連接語句在兩個可擴展連接器中引入變量：必須至少存在其中一個：\n/P1";
DYNConnectExpandFailed.Request="未能展開 /P1";
DYNExandableConnMultLevels.Request="在可擴展連接器中引入多個層次結構級別（非法但可用）：/P1";
DYNConnectFailure.Request="連接 /P1 展開時失敗。";
DYNConnectNonConnectors.Request="連接沒有參考 /P1 中的連接器";
DYNLogRecComps.Request="變量 /P1 含有部件";
DYNLogRecComps.Diagnostic="/P2。";
DYNConnectingBusToNonBus.Request="連接總線 /P1 和非總線 /P2";
DYNConnectingNonBusToBus.Request="連接非總線 /P1 和總線 /P2";
DYNConnectorOperatorRecordAndOther.Request="/P1 和 /P2 的運算符記錄和非運算符記錄之間的連接";
DYNConnectorOperatorRecordMismatch.Request="/P1 和 /P2 的不同運算符記錄之間的連接";
DYNConnectorToSimpleVar.Request="連接連接器變量 /P1 和簡單變量 /P2。";
DYNConnectionDimMismatch.Request="/P1 和 /P2 的數組尺寸的數目不匹配。";
DYNConnectionSizeMismatch.Request="/P1/P2 和 /P3/P4 的數組尺寸不匹配";
DYNConnectIncompatibleComponents.Request="不兼容的 /P1 和 /P2";
DYNConnSimpleVarToConn.Request="連接簡單變量 /P1 和連接器變量 /P2。";
DYNConnFlowToNonFlow.Request="連接流變量 /P1 和非流變量 /P2。";
DYNConnectTwoInsideInput.Request="連接兩個內部連接器（=子模型中的連接器）";
DYNConnectTwoInsideInput.Diagnostic="包含輸入部件 /P1 和 /P2。";
DYNConnectTwoInsideOutput.Request="連接兩個內部連接器（=子模型中的連接器）";
DYNConnectTwoInsideOutput.Diagnostic="包含輸出部件 /P1 和 /P2。";
DYNConnectTwoOutsideInput.Request="連接兩個外部連接器（=子模型中的連接器）";
DYNConnectTwoOutsideInput.Diagnostic="包含輸入部件 /P1 和 /P2。";
DYNConnectTwoOutsideOutput.Request="連接兩個外部連接器（=子模型中的連接器）";
DYNConnectTwoOutsideOutput.Diagnostic="包含輸出部件 /P1 和 /P2。";
DYNKernelLogMessage_0078.Request="/P2 的輸入連接器 /P1 從外部連接，且還包含值。";
DYNKernelLogMessage_0078.Diagnostic="這可能導致奇點。";
DYNKernelLogMessage_0072A.Request="注意：/P2 的輸入連接器 /P1 的一些元素未從外部連接。";
DYNKernelLogMessage_0072A.Diagnostic="",
"假定正常，因為已使用了它們的基數。";
DYNKernelLogMessage_0072B.Request="/P2 的輸入連接器 /P1 的一些元素未從外部連接。";
DYNKernelLogMessage_0072B.Diagnostic="",
"它們很可能已經連接，遞歸檢查將假設已連接。\n",
"缺少連接很可能是因為模型中存在錯誤。";
DYNKernelLogMessage_0078b.Request="注意：/P2 的輸入連接器 /P1 未從外部連接。";
DYNKernelLogMessage_0078b.Diagnostic="",
"假定正常，因為已使用了它的基數。";
DYNKernelLogMessage_0078a.Request="/P2 的輸入連接器 /P1 未從外部連接。";
DYNKernelLogMessage_0078a.Diagnostic="",
"它很可能已經連接，遞歸檢查將假設已連接。\n",
"缺少連接很可能是因為模型中存在錯誤。";
DYNBlockWConnectExpandFailed.Request="無法展開包含連接的塊";
DYNBlockWConnectExpandFailed.Diagnostic="/P1";
DYNKernelLogMessage_0084.Request="記錄的連接方程式";
DYNKernelLogMessage_0085A.Request="  生成 1 個默認連接。";
DYNKernelLogMessage_0085B.Request="  生成 /P1 默認連接。";
DYNKernelLogMessage_ConnectorSizingUnconnected.Request="使用帶標注的參數標注尺寸的連接器不一致(Dialog(connectorSizing=true))。";
DYNKernelLogMessage_ConnectorSizingUnconnected.Diagnostic="",
" 部分連接器元素未連接。\n",
"這是因為連接和/或參數已經以文本方式編輯成不一致的狀態\n",
"或因為參數的默認值并非 0。未連接的連接器為：\n/P1";
DYNKernelLogError_0046.Request="錯誤：使用單引號的標識符：/P1 在 /P2 行 /P3 中跨越多行。";
DYNKernelLogError_0046.Diagnostic="",
"  對于字符串，請使用雙引號 \"...\"。\n",
"  對于 x'=transpose(x)，請使用 transpose(x) 或\n",
"設置 /P4=false，以允許將 ' 用于轉置。\n";
DYNKernelLogError_0047.Request="錯誤：未能寫入 /P1。";
DYNKernelLogError_0048.Request="錯誤：未能打開 /P1。";
DYNKernelLogError_0049.Request="錯誤：未能打開 /P1。";
DYNKernelLogError_0050.Request="錯誤：無法寫入 /P1。";
DYNKernelLogError_0051.Request="錯誤：未能打開 /P1。";
DYNKernelLogMessage_0086.Request="不支持讀取記錄變量 /P1。";
DYNKernelLogWarning_0012.Request="警告：設置 /P1 在模型中無效。";
DYNKernelLogWarning_0012.Diagnostic="轉換后，您只能設置字面起始值和非求值參數。\n";
DYNKernelLogWarning_0013.Request="警告：轉換后，/P1 并非可設置的參數。";
DYNKernelLogWarning_0014.Request="警告：/P1 變量 /P2 與值 /P3 不兼容。";
DYNKernelLogWarning_0015.Request="警告：/P1 變量 /P2 與值 /P3 不兼容。";
DYNKernelLogWarning_0016.Request="警告：/P1 變量 /P2 與值 /P3 不兼容。";
DYNKernelLogMessage_0087.Request="嘗試在變量 /P1 中存儲非字面值。";
DYNKernelLogMessage_0088.Request="無法將模型參數 /P1 設置為字符串值。";
DYNKernelLogMessage_0088.Diagnostic="轉換后，無法設置模型中的字符串參數。\n";
DYNKernelLogMessage_0089.Request="變量 /P1 為記錄。";
DYNKernelLogMessage_0089.Diagnostic=" 不支持設置整個記錄。\n";
DYNKernelLogMessage_0090.Request="嘗試將數組存儲在標量變量 /P1 中。";
DYNKernelLogMessage_0091.Request="在范圍 /P1 中，嘗試使用";
DYNKernelLogMessage_0091.Diagnostic=" /P3 的短 /P2，\n 但找到 /P4。\n";
DYNKernelLogMessage_0092.Request="在范圍 /P1 中，嘗試使用 /P2，";
DYNKernelLogMessage_0092.Diagnostic=" 但找到 /P3。\n";
DYNKernelLogMessage_0093.Request="生成導入 /P1 = /P2";
DYNKernelLogMessage_0093.Diagnostic=" 位于范圍 /P3\n 中，以在 /P5 中找到 /P4。\n";
DYNErrorsFoundInRhsmod.Request="在以下項中發現錯誤：/P1";
DYNErrorsFoundInLhsRhsmod.Request="在以下項中發現錯誤：/P1 = /P2";
DYNKernelLogError_0052.Request="錯誤：內部錯誤：在方程式塊中找不到方程。";
DYNKernelLogMessage_0095.Request="繼續行";
DYNKernelLogError_0053.Request="聲明窗口中存在多個聲明。";
DYNKernelLogError_0054.Request="聲明窗口中沒有聲明";
DYNKernelLogError_0055.Request="";
DYNFailureToAllocateArrayElements.Request="無法分配數組元素。";
DYNContactDynasim.Request="請與支持人員聯系。";
DYNMixedStateAlgArray.Request="數組變量 /P1 同時包含動態元素和代數元素，";
DYNMixedStateAlgArray.Diagnostic="且它存在未展開的參考。";
DYNMixedStateAlgArray1.Request="dsmodel 的分配方案無法處理此情況。";
DYNMixedStateAlgArray2.Request="未展開參考的典型原因是用作";
DYNMixedStateAlgArray2.Diagnostic="帶函數數組的表達式中的函數或外觀參數。";
DYNMixedStateAlgArray3.Request="在有關位置引入另一緊鄰參數，即可修復模型。";
DYNFixingParameterValues.Request="參數 /P1 包含一些固定為常量的元素";
DYNFixingParameterValues.Diagnostic="/P2\n，\n因為它們可控制結構屬性，如數組大小。";
DYNFixingParameterValues1.Request="參數數組存在未展開的參考，";
DYNFixingParameterValues1.Diagnostic="而 dsmodel 的分配方案無法正確處理此情況";
DYNFixingParameterValues2.Request="因此，所有元素將聲明為參數，但所列出元素的交互式設置并無影響。";
DYNConvertedOutputToState.Request="輸出變量 /P1 必須轉換為狀態。";
DYNConvertedOutputToState1.Request="要避免出現此消息，請將 der 應用于中間變量。";
DYNValueNotInRange.Request="值=/P1 不在變量 /P4 的范圍 [/P2,/P3] 內。";
DYNValueNotInRange1.Request="忽略范圍";
DYNInlineIntegrationNonFixedStart.Request="狀態 /P1 固定為 false。";
DYNInlineIntegrationNonFixedStart.Diagnostic="內聯集成不支持此設置。";
DYNKernelLogWarning_0021.Request="警告：狀態 /P1 固定為 false。";
DYNKernelLogWarning_0021.Diagnostic="",
"  內聯集成不支持此設置，請使用初始計算\n",
"（無內聯集成） 以構造腳本設置起始值\n",
"，并使用此腳本初始化模型。\n";
DYNFailureToAllocateVars.Request="分配變量失敗。";
DYNKernelLogError_0057.Request="生成代碼時發生內部錯誤，請與支持人員聯系。";
DYNKernelLogError_0058.Request="未知類型的空數組。";
DYNCannotComputeSizesForEmptyRec.Request="無法計算空記錄 /P1 的大小。";
DYNIndexingEmptyMatrix.Request="對空矩陣編制索引時出錯。";
DYNNoElementsOfType.Request="問題是沒有類型 /P1 的元素。";
DYNRegNumberElementsOfType.Request="問題是元素類型 /P1 的結構化正則。";
DYNRegNumberElementsOfType.Diagnostic="",
"標量 /P1 元素的數目為 /P2。";
DYNSingNumberElementsOfType.Request="問題是元素類型 /P1 的結構奇點。";
DYNSingNumberElementsOfType.Diagnostic="",
"標量 /P1 未知元素的數目為 /P2。\n",
"標量 /P1 方程式元素的數目為 /P3。";
DYNRemovedExpandableConnectors3.Request="以下可擴展連接器變量未在模型中使用，";
DYNRemovedExpandableConnectors3.Diagnostic="且將從連續錯誤診斷中移除：\n/P1";
DYNRemovedConnectors3.Request="以下可擴展連接器變量未在模型中使用，";
DYNRemovedConnectors3.Diagnostic="且將從連續錯誤診斷中移除：\n/P1";
DYNNonAppearingUnknowns.Request="以下變量視為未知量，但不會出現在方程式中。";
DYNNonAppearingUnknowns.Diagnostic="/P1";
DYNModelHint.Request="模型包括以下提示";
DYNModelHint.Diagnostic="/P1";
DYNNoUnknownsEqu.Request="沒有可從方程式求解的 /P1 未知量";
DYNEquation.Request="/P1";
DYNEquationDerivedFrom.Request="  派生自";
DYNEquationDerivedFrom.Diagnostic="/P1";
DYNOverderminedElType.Request="/P1 元素的問題零件超定。";
DYNOverderminedElTypeA.Request="過多 /P1 標量方程式";
DYNOverderminedElTypeA.Diagnostic="在 /P2 方程式集中\n",
"未列出，原因是數量過多。\n",
"為了獲得更好的診斷，\n您可以單獨檢查每個部件，\n或移除連接。";
DYNOverderminedElTypeB1.Request="集合中 /P1 標量方程式過多";
DYNUnderdeterminedProblem.Request="/P1 元素的問題零件欠定。 ";
DYNUnderdeterminedProblemRealVarOrDer.Request="缺少變量或其導數的 /P1 標量 /P2  方程式。";
DYNUnderdeterminedProblemReal.Request="缺少變量的 /P1 標量 /P2  方程式。";
DYNUnassignedInputs.Request="不定變量聲明為輸入";
DYNUnassignedInputs.Diagnostic="/P1";
DYNUnassignedOutputs.Request="不定變量聲明為輸出";
DYNUnassignedOutputs.Diagnostic="/P1";
DYNUnassignedUnknowns1.Request="不定原因變量";
DYNUnassignedUnknowns1.Diagnostic="/P1";
DYNUnassignedUnknowns2A.Request="和其他 /P1 不定變量。";
DYNUnassignedUnknowns2A.Diagnostic="",
"由于這些變量數量過多，因此沒有列出。\n",
"為了獲得更好的診斷，\n您可以單獨檢查每個部件，\n或移除連接。";
DYNUnassignedUnknowns5.Request="不定變量";
DYNUnassignedUnknowns5.Diagnostic="/P1";
DYNUnassignedUnknowns2B.Request="存在 /P1 不定變量。";
DYNUnassignedUnknowns2B.Diagnostic="",
"由于這些變量數量過多，因此沒有列出。\n",
"為了獲得更好的診斷，\n您可以單獨檢查每個部件，\n或移除連接。";
DYNModelHasStructSingComponent1Part.Request="模型 /P1 部件 /P2 為結構奇點。";
DYNModelIsSingular1PartA.Request="模型 /P1 為結構奇點。";
DYNModelIsSingular1PartB1.Request="模型 /P1 為結構奇點， ";
DYNModelIsSingular1PartB1.Diagnostic="",
"前提是假定輸入為已知量\n，且最一般的外部接頭為其連接器的所有流變量。";
DYNModelIsSingular1PartB2.Request="模型 /P1 為結構奇點， ";
DYNModelIsSingular1PartB2.Diagnostic="",
"前提是假定輸入為已知量。";
DYNModelIsSingular1PartB3.Request="模型 /P1 為結構奇點， ";
DYNModelIsSingular1PartB3.Diagnostic="",
"前提是假定最一般的外部接頭為其連接器的所有流變量。";
DYNModelHasStructSing1.Request="模型 /P1 具有非物理連接器且正常，";
DYNModelHasStructSing2.Request="模型 /P1 部件在頂層為結構奇點。";
DYNModelHasStructSingComponentA.Request="模型/P1 部件/P2 具有非物理連接器且正常，";
DYNModelHasStructSingComponentB.Request="模型 /P1 部件 /P2 為結構奇點。";
DYNModelIsSingularA1.Request="模型 /P1 為結構奇點。";
DYNModelIsSingularA.Request="模型 /P1 為結構奇點，";
DYNModelIsSingularB.Request="模型 /P1 具有非物理連接器且正常， ";
DYNModelIsSingularB1A.Request="前提是假定輸入為已知量，";
DYNModelIsSingularB1A.Diagnostic="且最一般的外部接頭為其連接器的所有流變量\n，以及非物理連接器將強加適當的約束。";
DYNModelIsSingularB1B.Request="前提是假定輸入為已知量，";
DYNModelIsSingularB1B.Diagnostic="且最一般的外部接頭為其連接器的所有流變量。";
DYNModelIsSingularB2A.Request="前提是假定輸入為已知量，";
DYNModelIsSingularB2A.Diagnostic="以及非物理連接器將強加適當的約束。";
DYNModelIsSingularB2B.Request="前提是假定輸入為已知量。";
DYNModelIsSingularB3A.Request="前提是假定最一般的外部接頭為其連接器的所有流變量";
DYNModelIsSingularB3A.Diagnostic="以及非物理連接器將強加適當的約束。";
DYNModelIsSingularB3B.Request="前提是假定最一般的外部接頭為其連接器的所有流變量。";
DYNModelIsSingularC.Request="前提是假定非物理連接器將強加適當的約束。";
DYNConnectorsNotConnectedOnOutside.Request="部分連接器未從外部連接";
DYNConnectorsNotConnectedOnOutside.Diagnostic="/P1";
DYNDymolaDifferentiatedMode.Request="此操作不支持譯自 Dymola 語言的此模型。";
DYNRedundantConsistentEqu.Request="找到冗余一致的方程式";
DYNRedundantConsistentEqu.Diagnostic="/P1";
DYNWasSingular.Request="問題為奇點。";
DYNWasSingular1.Request="以下修改導致一致的問題";
DYNWasSingular2.Request="以下變量設置為常量值";
DYNWasSingular2.Diagnostic="/P1";
DYNNeglectedAdditionalConsistentEqus.Request="以下其他一致的方程式被忽略";
DYNSingModelA.Request="模型為奇點";
DYNSingModelA1a.Request="非零解標量方程式的數目為 /P1。";
DYNSingModelA1b.Request="標量方程式的數目為 /P1。";
DYNSingModelA2.Request="標量變量的數目為 /P1。";
DYNSingModelA3.Request="未指派的變量";
DYNSingModelA3.Diagnostic="/P1";
DYNSingModelA4.Request="其他方程式";
DYNKernelLogMessage_0103.Request="復制變量：/P1";
DYNKernelLogMessage_0104.Request="變量不應該位于映射中：/P1";
DYNKernelLogMessage_0105.Request="/P1 /P2 的錯誤";
DYNKernelLogMessage_0106.Request="/P1 /P2 的 P。錯誤";
DYNKernelLogMessage_0107.Request="/P1 /P2 的 P。Inbetween 錯誤";
DYNKernelLogMessage_0108.Request="/P1 /P2 的 Inbetween 錯誤";
DYNKernelLogMessage_0109.Request="已經將變量 /P1 添加為 /P2";
DYNKernelLogMessage_0110.Request="位置中 /P1 不匹配";
DYNKernelLogMessage_0111.Request="Varmap 找到 /P1";
DYNKernelLogMessage_0112.Request="Varset 找到 /P1";
DYNKernelLogMessage_0113.Request="位置中 /P1 /P2 不匹配";
DYNIndexReductionFailed.Request="減少索引失敗。";
DYNGenericFailure.Request="出現內部錯誤";
DYNFailedAssignDummyDerEqu.Request="無法指派動態狀態選擇系統。";
DYNFailedAssignDummyDerEqu.Diagnostic="它包含 /P1  元素";
DYNFailedAssignEqu.Request="無法指派方程式";
DYNFailedAssignEqu.Diagnostic="/P1";
DYNFailedAssignEqu1.Request="它不含未知變量。";
DYNLogNumberOfUnknowns.Request="未知量的數目為 /P1。";
DYNLogNumberOfEquations.Request="方程式的數目為 /P1。";
DYNFailedDeselecOfStates.Request="虛擬取消選擇狀態失敗。";
DYNFailedDeselecOfStates.Diagnostic="方程式：\n/P1\n虛擬\n/P2\n虛擬候選項：\n/P3\n選定的虛擬：\n/P4";
DYNKernelLogError_0060.Request="查找最高階導數時發生內部錯誤。";
DYNKernelLogError_0061.Request="內部錯誤：變量 /P1 未展開。";
DYNDAEIndexHighMaybeSingProb.Request="差分方程式的索引數量較大，可能是不一致的方程式。";
DYNFailedDiffFirstConditionalConstraint.Request="無法區分第一個條件約束";
DYNFailedDiffFirstConditionalConstraint.Diagnostic="/P1\n，以便減少 DAE 索引。";
DYNFailedDiffEqu.Request="無法區分方程式";
DYNFailedDiffEqu.Diagnostic="/P1\n，以便減少 DAE 索引。";
DYNFailedDiffEqu1.Request="Dymola 當前無法區分算法。";
DYNFailedDiffEqu5.Request="方程式會參考外部輸入";
DYNFailedDiffEqu5.Diagnostic="/P1\n，但無法區分外部輸入。";
DYNFailedDiffEqu3.Request="Dymola 當前無法處理涉及非 real 方程式的索引減少。";
DYNFailedDiffEqu2.Request="Dymola 當前無法區分此類非標量方程式。";
DYNFailedDiffEqu4.Request="Dymola 當前只能處理";
DYNFailedDiffEqu4.Diagnostic="涉及多重返回函數 if 的索引減少\n  1。 已指定其派生函數\n  2。 它只會返回實際輸出。";
DYNLogDiffEqu.Request="區分方程式";
DYNLogDiffEqu.Diagnostic="/P1 為 /P2 提供";
DYNUnexpandedNonScalarEqu.Request="未展開的非標量方程式";
DYNUnexpandedNonScalarEqu.Diagnostic="/P1";
DYNFailedIndexRedModelMayBeSing.Request="索引減少失敗。模型可能為奇點。";
DYNNoStateDummiesForEqu.Request="方程式";
DYNNoStateDummiesForEqu.Diagnostic="/P1\n約束連續時間變量：";
DYNNoStateDummiesForEqu1.Request="在 reinit 子句中設置以下變量";
DYNNoStateDummiesForEqu1.Diagnostic="/P1";
DYNNoStateDummiesForEqu2.Request="以下變量設置 stateSelect = StateSelect.always";
DYNNoStateDummiesForEqu2.Diagnostic="/P1";
DYNNoStateDummiesForEqu3.Request="要求變量為連續時間狀態變量。";
DYNNoStateDummiesForEqu3.Diagnostic="必須修改 stateSelect 屬性或模型。";
DYNLogDummyDerSelection.Request="調用虛擬導數選擇";
DYNLogDummyDerSelection.Diagnostic="去除的變量：\n/P1\n虛擬假造項：\n/P2\n方程式：\n/P3";
DYNTooManyRequiredStates.Request="過多變量需要成為狀態。";
DYNTooManyRequiredStates1.Request="在 reinit 子句中設置以下變量";
DYNTooManyRequiredStates1.Diagnostic="/P1";
DYNTooManyRequiredStates2.Request="以下變量設置 stateSelect = StateSelect.always";
DYNTooManyRequiredStates2.Diagnostic="/P1";
DYNTooManyRequiredStates3.Request="要求變量為連續時間狀態變量。";
DYNTooManyRequiredStates4.Request="但是，這就是說至少 /P1 過多。";
DYNTooManyRequiredStates4.Diagnostic="必須修改 stateSelect 屬性或模型。";
DYNSingModelC4.Request="其他方程式";
DYNIndexFailedNonScalarEqu.Request="無法減小 DAE 索引和選擇狀態，";
DYNIndexFailedNonScalarEqu.Diagnostic="因為它涉及非標量方程：\n/P1";
DYNIndexFailedNonDiffEqu.Request="無法減小 DAE 索引和選擇狀態。";
DYNIndexFailedNonDiffEqu.Diagnostic="這最可能是由于函數不可微分。";
DYNFailedSortingInitEqus.Request="對初始化方程排序失敗。";
DYNFailedDiffSecondConditionalConstraint.Request="無法微分第二條件約束";
DYNFailedDiffSecondConditionalConstraint.Diagnostic="/P1\n，以便減少 DAE 索引。";
DYNUniqueRootMessage.Request="/P1";
DYNOverdeterminedConnectorsBad.Request="處理多種因素確定的連接器出錯或失敗。";
DYNOverDeterminedConnectorsBadArgument.Request="/P1 中的參數不正確";
DYNMultipleConnRoot.Request="/P1 有多個 Connections.root 或 Connections.uniqueRoot";
DYNMultipleConnPotentialRoot.Request="/P1 有多個 Connections.potentialRoot";
DYNBothUniqueConnRoots.Request="/P1 有 Connections.uniqueRoot 和 Connections.potentialRoot";
DYNBothConnRoots.Request="/P1 有 Connections.root 和 Connections.potentialRoot";
DYNMConnBranchBadArg.Request="/P1 的 Connections.branch 的參數完全相同";
DYNConnBranch2RootsA.Request="兩個根節點之間有一系列不可間斷的分支。";
DYNConnBranch2RootsB.Request="Connections.branch 方程";
DYNConnBranch2RootsB.Diagnostic="/P1\n 意味著 \n/P2 和 /P3\n 由不可間斷的分支連接。";
DYNConnBranch2UniqueRootsA.Request="兩個獨立根節點之間有一系列不可間斷的分支。";
DYNConnBranch2UniqueRootsB.Request="Connections.branch 方程";
DYNConnBranch2UniqueRootsB.Diagnostic="/P1\n 意味著 \n/P2 和 /P3\n 由不可間斷的分支連接。";
DYNConnBranchUniqueRootandRootA.Request="獨立的根與根節點之間有一系列不可間斷的分支。";
DYNConnBranchUniqueRootandRootB.Request="Connections.branch 方程";
DYNConnBranchUniqueRootandRootB.Diagnostic="/P1\n 意味著 \n/P2 和 /P3\n 由不可間斷的分支連接。";
DYNNOnBreakableCycle.Request="不可間斷的分支引入了一個節拍";
DYNNOnBreakableCycle.Diagnostic="/P1";
DYNSameConnectionArgs.Request="連接 /P1 中的參數完全相同";
DYNConnected2UniqueRootsA.Request="連接了兩個獨立的根。";
DYNConnected2UniqueRootsB.Request="連接方程";
DYNConnected2UniqueRootsB.Diagnostic="/P1\n 意味著唯一根 /P2 和 /P3 已連接。";
DYNDYNConnectedUniqueRootandRootA.Request="唯一根與根已連接。";
DYNConnectedConnUniqueRootandRootB.Request="連接方程";
DYNConnectedConnUniqueRootandRootB.Diagnostic="/P1 意味著唯一根 \n/P2 與根 /P3\n 已連接。";
DYNCouldNotEvalRootPrio1.Request="無法評估優先級";
DYNCouldNotEvalRootPrio1.Diagnostic="/P1";
DYNCouldNotEvalRootPrio2A.Request="所選 /P1 具有優先級 /P2。";
DYNCouldNotEvalRootPrio2B.Request="已選擇 /P1。";
DYNMissingRoot.Request="由過多因素確定的連接器";
DYNMissingRoot.Diagnostic="/P1\n 已連接，但是未定義任何根。";
DYNFailedEvalRootedCall.Request="對根函數調用求值時失敗。";
DYNIsolatedOverdetrminedConnector.Request="連接器 /P1";
DYNIsolatedOverdetrminedConnector.Diagnostic="是隔離的由多種因素確定的連接器，不作為根。";
DYNLogOverdeterminedConnectors.Request="處理多種因素確定的連接器的結果";
DYNLogOverdeterminedConnectors1A.Request="沒有確定的根。";
DYNLogOverdeterminedConnectors1B.Request="確定根";
DYNLogOverdeterminedConnectors1B.Diagnostic="/P1";
DYNLogOverdeterminedConnectors2B.Request="唯一根";
DYNLogOverdeterminedConnectors2B.Diagnostic="/P1";
DYNLogOverdeterminedConnectors2A.Request="未選擇可能的根。";
DYNLogOverdeterminedConnectors2C.Request="已選擇可能的根";
DYNLogOverdeterminedConnectors2C.Diagnostic="/P1";
DYNLogOverdeterminedConnectors3A.Request="找不到由過多因素確定的連接。";
DYNLogOverdeterminedConnectors3B.Request="已刪除冗余方程的連接";
DYNLogOverdeterminedConnectors3B.Diagnostic="/P1";
DYNUniqueRootIndicesDifferentSizes.Request="對于 /P1";
DYNUniqueRootIndicesDifferentSizes.Diagnostic="第一個參數有 /P2 個元素，第二個參數的元素個數必須小于該數。\n但是，它有 /P3 個元素。";
DYNUniqueRootIndicesNoNode.Request="對于 /P1";
DYNUniqueRootIndicesNoNode.Diagnostic=" 變量 /P2 不是一個連接器節點。";
DYNUniqueRootIndicesNoRoot.Request="對于 /P1";
DYNUniqueRootIndicesNoRoot.Diagnostic=" 節點 /P2 未連接到第一個參數的任何根。";
DYNUnigueRootIndicesMessage.Request="/P1";
DYNUniqueRootIndicesMultipleRoot.Request="對于 /P1";
DYNUniqueRootIndicesMultipleRoot.Diagnostic=" 根 /P2 仍然多于一個節點。";
DYNUniqueRootIndicesEvaluateLog.Request="調用 /P1";
DYNUniqueRootIndicesEvaluateLog.Diagnostic="已展開到：/P2 中。";
DYNRefToFloatBusInStart.Request="變量 /P2 的起始值 /P1 參考了未連接的可展開連接器";
DYNRefToFloatBusInStart.Diagnostic="/P3";
DYNRefToFloatBusInBinding.Request="變量 /P2 的綁定 /P1 參考了未連接的可展開連接器";
DYNRefToFloatBusInBinding.Diagnostic="/P3";
DYNRefToFloatBusInInitialEqu.Request="初始方程，";
DYNRefToFloatBusInInitialEqu.Diagnostic=" /P1 參考了未連接的可展開連接器：\n/P2";
DYNLogFloatBusVariables.Request="以下可展開總線連接器已被移除，因為它們未連接而是浮動的";
DYNLogFloatBusVariables.Diagnostic="/P1";
DYNLogNoFloatBusVariables.Request="所有可展開總線連接器均已連接，并且將會進行計算。";
DYNFailedStructuralAnalysis.Request="結構分析已失敗。";
DYNFailedElementTypeClassification.Request="對元素類型的分類已失敗。";
DYNDAESize.Request="DAE 有 /P1 個標量未知數和 /P2 個標量方程。";
DYNModelSizeOK.Request="模型具有的未知數和方程數量相同：/P1";
DYNModelSizeDiff.Request="模型有 /P1 個標量未知數和 /P2 個標量方程。";
DYNStructSingError1.Request="問題是結構性異常。";
DYNStructSingError1.Diagnostic="",
"它有 /P1 個標量未知數和 /P2 個標量方程。\n",
"  實數部分有 /P3 個未知數和 /P4 個方程。\n",
"  整數部分有 /P5 個未知數和 /P6 個方程。\n",
"  布爾值部分有 /P7 個未知數和 /P8 個方程。\n",
"  字符串部分有 /P9 個未知數和 /P10 個方程。";
DYNStructIncomplete1.Request="問題是結構不完整。";
DYNStructIncomplete1.Diagnostic="",
"它有 /P1 個標量未知數和 /P2 個標量方程。\n",
"  實數部分有 /P3 個未知數和 /P4 個方程。\n",
"  整數部分有 /P5 個未知數和 /P6 個方程。\n",
"  布爾值部分有 /P7 個未知數和 /P8 個方程。\n",
"  字符串部分有 /P9 個未知數和 /P10 個方程。";
DYNKernelLogMessage_0115.Request="試圖進一步本地化奇點。";
DYNKernelLogMessage_0115.Diagnostic="\n";
DYNKernelLogMessage_0116.Request="非異常問題的遞歸檢查。";
DYNKernelLogMessage_0117.Request="模型 /P1 結構不完整。";
DYNKernelLogMessage_0119.Request="試圖進一步本地化奇點。";
DYNKernelLogMessage_0119.Diagnostic="\n";
DYNKernelLogMessage_0120.Request="/P1 的奇點在頂層。";
DYNKernelLogMessage_0124.Request="/P1 的奇點在部件 /P2，類 /P3 中。";
DYNKernelLogMessage_0123.Request="/P1 的奇點在部件 /P2 中。";
DYNKernelLogMessage_0125.Request="無法本地化 /P1 的奇點。";
DYNReqAbortOfCheck.Request="用戶已請求中止檢查。";
DYNReqAbortOfTransl.Request="用戶已請求中止轉換。";
DYNMIssingFunctionBodyCheck.Request="函數 /P1 既不是外部函數，也沒有算法。在使用前必須重新聲明。";
DYNMIssingFunctionBody.Request="函數 /P1 既不是外部函數，也沒有算法。應當重新聲明。";
DYNKernelLogError_0062.Request="抱歉，當前版本無法處理非函數中的非參數字符串 /P1。";
DYNDefEquBad.Request="定義方程中的表達式無效：/P1 = /P2";
DYNStateNamesBad.Request="數組 /P1 必須是字符串數組。";
DYNStateNamesNoValue.Request="數組 /P1 沒有邊界值。";
DYNStateNamesNonLitValue.Request="數組 /P1 作為非文字元素值：/P2";
DYNStateNamesNonParseValue.Request="數組 /P1 有不可解析的變量名 /P2。";
DYNStateNamesExpandFailure.Request="在展開數組 /P2 中的變量 /P1 時";
DYNStateNamesNonResolve.Request="數組 /P1 有無法解析的變量名 /P2。";
DYNKernelLogError_0063.Request="無法置亂異構（記錄綁定）數組 /P1。";
DYNKernelLogError_0064.Request="無法置亂異構（固定）數組 /P1。";
DYNKernelLogError_0065.Request="無法置亂異構（最小）數組 /P1。";
DYNKernelLogError_0066.Request="無法置亂異構（最大）數組 /P1。";
DYNKernelLogError_0067.Request="無法置亂異構（標稱）數組 /P1。";
DYNKernelLogError_0068.Request="無法置亂異構（狀態選擇）數組 /P1。";
DYNKernelLogError_0069.Request="無法置亂異構（綁定）數組 /P1。";
DYNKernelLogError_0070.Request="無法置亂異構（流）數組 /P1。";
DYNKernelLogError_0071.Request="無法置亂異構（因果）數組/P1。";
DYNKernelLogError_0072.Request="無法置亂異構（類型）數組 /P1。";
DYNKernelLogError_0073.Request="無法置亂異構（變異性）數組 /P1。";
DYNKernelLogError_0074.Request="無法置亂異構（維度）數組 /P1。";
DYNKernelLogError_0075.Request="無法置亂異構（尺寸）數組 /P1。";
DYNKernelLogError_0076.Request="無法置亂異構（值）數組 /P1。";
DYNKernelLogError_0077.Request="無法置亂異構（起始）數組 /P1。";
DYNKernelLogError_0078.Request="異構數組 /P1 置亂出錯。";
DYNKernelLogError_0079.Request="置亂無法處理空數組 /P1。";
DYNKernelLogError_0080.Request="置亂無法處理數組 /P1 中的異構數組。";
DYNKernelLogError_0081.Request="置亂無法處理數組 /P1 中的異構數組。";
DYNKernelLogError_0082.Request="置亂記錄 /P1 時出錯。";
DYNKernelLogError_0083.Request="置亂記錄 /P1 時出錯。";
DYNKernelLogError_0084.Request="置亂記錄 /P1 時出錯。";
DYNKernelLogWarning_0022.Request="警告：無法保持 /P1 為參數，因為綁定了 /P2。";
DYNKernelLogWarning_0023.Request="警告：已對 /P1 求值。更改它沒有作用。";
DYNExpandErrorInConcealed.Request="展開隱式方程出錯或失敗。";
DYNExpandFailureEquA.Request="無法展開方程";
DYNExpandFailureEquA.Diagnostic="/P1";
DYNExpandFailureEqu.Request="展開方程出錯或失敗";
DYNExpandFailureEqu.Diagnostic="/P1";
DYNNewLine.Request="";
DYNCheckAborted1.Request="檢查 /P1 已中止。";
DYNCheckAborted2.Request="檢查類已中止。";
DYNCheckAborted3.Request="由 /P1 的故障已中止檢查。";
DYNCheckAborted4.Request="檢查已中止。";
DYNTranslationAborted.Request="平移已中止。";
DYNExpressionsBad.Request="模型含有無效的表達式。";
DYNMissingDeclarations.Request="缺少聲明。";
DYNInvalidConnects.Request="模型含有無效的連接語句。";
DYNFailedToGetInitialEquations.Request="分離初始化方程失敗。";
DYNExitFuncErr.Request="函數中檢測到錯誤。";
DYNBasicTypeErrors.Request="檢測到基本類型不一致。";
DYNAssVariabilityBad.Request="賦值的可變性";
DYNAssVariabilityBad.Diagnostic="/P1\n 不小于為每個記錄變量聲明的可變范圍。";
DYNRecordBindingErr.Request="記錄綁定中檢測到錯誤。";
DYNExitFailedExpandAdvice3.Request="未能展開可能是由于未知大小， ";
DYNExitFailedExpandAdvice3.Diagnostic="如果在使用部件時給定了大小，這種情況則不是錯誤。";
DYNBadVarDeclarations.Request="變量聲明中檢測到錯誤。";
DYNStringParNoValue.Request="字符串參數 /P1 沒有值，采用 /P2。";
DYNConcealdParNoValue.Request="隱式參數無值。";
DYNFailedToExpandParBinding.Request="展開參數綁定時出現故障。";
DYNFailedToSortParBinding.Request="對參數綁定排序時出現故障。";
DYNLogOrigEqu.Request="原始方程：/P1";
DYNParNamesBad.Request="找不到為參數進行修改的以下變量";
DYNParNamesBad.Diagnostic="/P1";
DYNInputNamesBad.Request="找不到為輸入進行修改的以下變量";
DYNInputNamesBad.Diagnostic="/P1";
DYNDoublySpecInputs.Request="為參數和輸入均指定了以下輸入變量";
DYNDoublySpecInputs.Diagnostic="/P1";
DYNDoublySpecUnknowns.Request="為參數和輸入均指定了以下變量";
DYNDoublySpecUnknowns.Diagnostic="/P1";
DYNFailedToExpandConditionalConstraint.Request="未能展開條件約束方程";
DYNFailedToExpandConditionalConstraint.Diagnostic=" /P1";
DYNWhenEquHardLHSA.Request="無法處理 when 方程得左側：+n/P1";
DYNWhenEquHardLHSB.Request="通過引入一個中間變量可以避開此問題";
DYNWhenEquBadLHS.Request="when 方程的左側不合法";
DYNWhenEquBadLHS.Diagnostic="/P1";
DYNWhenFailed.Request="處理 when 語句失敗。";
DYNHardInit.Request="由于 when 結構太復雜，Dymola 無法根據算法進行初始化";
DYNHardInit.Diagnostic="/P1";
DYNLogExpandedEqu.Request="展開方程：/P1";
DYNKernelLogWarning_0024.Request="二進制模型導出失敗。沒有 /P1 的導出許可";
DYNKernelLogError_0086.Request="";
DYNKernelLogMessage_0131.Request="找到 /P1 個常量。";
DYNKernelLogMessage_0132.Request="找到 /P1 個參數約束變量。";
DYNKernelLogMessage_0133.Request="找到 /P1 個別名變量。";
DYNKernelLogMessage_0134.Request="/P1 個與剩余時間有關的變量。";
DYNKernelLogMessage_0135.Request="找到 /P1 個常量。";
DYNKernelLogMessage_0136.Request="找到 /P1 個參數約束變量。";
DYNKernelLogMessage_0137.Request="找到 /P1 個別名變量。";
DYNKernelLogMessage_0138.Request="/P1 個與剩余時間有關的變量。";
DYNKernelLogMessage_0139.Request="消除后";
DYNKernelLogMessage_0139.Diagnostic="非用戶（非平凡）方程：/P1\n用戶（含平凡）方程：/P2\n";
DYNKernelLogError_0087.Request="";
DYNKernelLogMessage_0140.Request="找到 /P1 個常量。";
DYNKernelLogMessage_0141.Request="找到 /P1 個參數約束變量。";
DYNKernelLogMessage_0142.Request="找到 /P1 個別名變量。";
DYNKernelLogMessage_0143.Request="/P1 個與剩余時間有關的變量。";
DYNKernelLogMessage_0144.Request="找到 /P1 個常量。";
DYNKernelLogMessage_0145.Request="找到 /P1 個參數約束變量。";
DYNKernelLogMessage_0146.Request="找到 /P1 個別名變量。";
DYNKernelLogMessage_0147.Request="/P1 個與剩余時間有關的變量。";
DYNKernelLogError_0088.Request="";
DYNKernelLogMessage_0148.Request="部件（非連接器/類型）：/P1";
DYNKernelLogMessage_0148.Diagnostic="非用戶（非平凡）方程：/P2\n",
"用戶（含平凡）方程：/P3\n外部方程：/P4";
DYNProblemHasRedundantEqus.Request="問題有冗余方程";
DYNProblemHasRedundantEqus.Diagnostic="/P1";
DYNKernelLogMessage_0149.Request="/P1 個未知數。";
DYNKernelLogMessage_0150.Request="找到 /P1 個常量。";
DYNKernelLogMessage_0151.Request="找到 /P1 個參數約束變量。";
DYNKernelLogMessage_0153.Request="/P1 個與剩余時間有關的變量。";
DYNDymolaDifferentiatedMode.Request="此操作不支持譯自 Dymola 語言的此模型。";
DYNKernelLogMessage_0154.Request="找到 /P1 個常量。";
DYNKernelLogMessage_0155.Request="找到 /P1 個參數約束變量。";
DYNKernelLogMessage_0156.Request="找到 /P1 個別名變量。";
DYNKernelLogMessage_0157.Request="/P1 個與剩余時間有關的變量。";
DYNLogResConstAliasElimination.Request="常量和別名消除的結果。";
DYNLogResConstAliasElimination1.Request="常量";
DYNLogResConstAliasElimination1.Diagnostic="/P1";
DYNLogResConstAliasElimination2.Request="綁定至參數表達式的變量";
DYNLogResConstAliasElimination2.Diagnostic="/P1";
DYNLogResConstAliasElimination3.Request="時變變量";
DYNLogResConstAliasElimination3.Diagnostic="/P1";
DYNLogResConstAliasElimination4.Request="時變方程";
DYNLogResConstAliasElimination4.Diagnostic="/P1";
DYNMultiReinit.Request="/p1 有多次重新初始化。";
DYNMultiReinit.Diagnostic="如果事件不是互斥的，則行為具有不確定性。";
DYNNeglectedStateSelectNever1.Request="變量 /P1 的 stateSelect = StateSelect.never 設定";
DYNNeglectedStateSelectNever1.Diagnostic="與重新初始化語句矛盾，\n  /P2 要求它處于連續時間狀態。";
DYNNeglectedStateSelectNever2.Request="因此其 stateSelect 設置為 StateSelect.never 被忽略。";
DYNFailedToWrapEqu.Request="無法處理方程";
DYNFailedToWrapEqu.Diagnostic="/P1";
DYNReinitOnNonState.Request="變量 /P1 未處于連續時間狀態，";
DYNReinitOnNonState.Diagnostic="這意味著現有的重新初始化無效。";
DYNReinitOnDeselectedState.Request="變量 /P1 已被作為連續時間狀態取消選擇，";
DYNReinitOnDeselectedState.Diagnostic="這意味著現有的重新初始化無效。";
DYNKernelLogMessage_0158.Request="將文件加密成 /P1 失敗。";
DYNKernelLogMessage_0159.Request="生成文件失敗。";
DYNKernelLogError_0089.Request="錯誤：匯編 dsmodel.c 出現問題";
DYNKernelLogError_0089.Diagnostic="請檢查當前目錄的文件許可權限。\n";
DYNKernelLogError_0090.Request="錯誤：無法匯編 dsmodel.c。";
DYNKernelLogError_0090.Diagnostic="請檢查當前目錄的文件許可權限。\n";
DYNKernelLogError_0091.Request="內部錯誤：嘗試編譯函數但是未找到。";
DYNFalseModelAssertListB1.Request="    變量 /P1 = /P2，已聲明 ";
DYNFalseModelAssertListB2.Request="    變量 /P1，已聲明 ";
DYNFalseModelAssertList.Request="以下聲明語句的條件始終為假";
DYNFalseModelAssertListA.Request="/P1";
DYNParNoValue.Request="以下參數不含任何值";
DYNParNoValue.Diagnostic="  /P1";
DYNParsNoValues.Request="以下參數不含任何值";
DYNParsNoValues.Diagnostic="/P1";
DYNParsNoDefault.Request="以下參數不含任何值，僅有一個起始值";
DYNParsNoDefault.Diagnostic="/P1";
DYNInputNoDefault.Request="以下輸入缺少約束方程";
DYNInputNoDefault.Diagnostic="/P1";
DYNInputsNoDefault.Request="以下輸入缺少約束方程";
DYNInputsNoDefault.Diagnostic="/P1";
DYNIterationVarsWithoutStart.Request="以下變量初始化問題的迭代變量";
DYNIterationVarsWithoutStart.Diagnostic="/P1\n，但是未為其給定任何明確的起始值。將使用零。";
DYNLogIterationStarts.Request="迭代變量的起始值";
DYNLogIterationStarts.Diagnostic="/P1";
DYNNeedInputDers.Request="模型需要";
DYNNeedInputDers1.Request="  /P1  /P2";
DYNSelectedStates.Request="選定的連續時間狀態";
DYNSelectedStates.Diagnostic="/P1";
DYNOneStateSelection.Request="有一組動態狀態選擇。";
DYNOneStateSelection1.Request="有一個待選狀態";
DYNOneStateSelection1.Diagnostic="/P1";
DYNOneStateSelection2.Request="有 /P1 個待選狀態";
DYNOneStateSelection2.Diagnostic="/P2";
DYNMultiStateSelection.Request="有 /P1 組動態狀態選擇。";
DYNMultiStateSelection1.Request="從集合 /P1 中，有 1 個待選狀態";
DYNMultiStateSelection1.Diagnostic="/P2";
DYNMultiStateSelection2.Request="從集合 /P1 中，有 /P2 個待選狀態";
DYNMultiStateSelection2.Diagnostic="/P3";
DYNTranslationStatistics.Request="統計信息";
DYNTranslationStatisticsA.Request="原始模型";
DYNTranslationStatisticsA1.Request="  部件數量：/P1";
DYNTranslationStatisticsA2.Request="  變量：/P1";
DYNTranslationStatisticsA3.Request="  常量：/P1 （/P2 標量）";
DYNTranslationStatisticsA4.Request="  參數：/P1（/P2 標量）";
DYNTranslationStatisticsA5.Request="  未知數：/P1（/P2 標量）";
DYNTranslationStatisticsA6.Request="  微分變量：/P1 標量";
DYNTranslationStatisticsA7.Request="  方程：/P1";
DYNTranslationStatisticsA8.Request="    非平凡：/P1";
DYNTranslationStatisticsB.Request="平移模型";
DYNTranslationStatisticsB1.Request="  常量：/P1 標量";
DYNTranslationStatisticsB2.Request="  自由參數：/P1 標量";
DYNTranslationStatisticsB3.Request="  依賴參數：/P1 標量";
DYNTranslationStatisticsB4.Request="  輸入：/P1 標量";
DYNTranslationStatisticsB5.Request="  輸出：/P1 標量";
DYNTranslationStatisticsB6.Request="  連續時間狀態：/P1 標量";
DYNTranslationStatisticsB7.Request="  時變變量：/P1 標量";
DYNTranslationStatisticsB8.Request="  別名變量：/P1 標量";
DYNTranslationStatisticsB9.Request="  假設默認初始條件：/P1";
DYNTranslationStatisticsC1.Request="  方程的混合實際/離散系統的數量：/P1";
DYNTranslationStatisticsC2.Request="  方程的線性系統的大小：/P1";
DYNTranslationStatisticsC3.Request="  操作線性系統后的大小：/P1";
DYNTranslationStatisticsC4.Request="  方程的非線性系統的大小：/P1";
DYNTranslationStatisticsC5.Request="  操作非線性系統后的大小：/P1";
DYNTranslationStatisticsD1.Request="  操作內聯隱式集成系統的大小：/P1";
DYNTranslationStatisticsE1.Request="  數值雅克比行列式的數量：/P1";
DYNTranslationStatisticsF1.Request="  初始化問題";
DYNTranslationStatisticsF2.Request="    方程的混合型真實/離散系統的數量：/P1";
DYNTranslationStatisticsF3.Request="    方程的線性系統的大小：/P1";
DYNTranslationStatisticsF4.Request="    操作線性系統后的大小：/P1";
DYNTranslationStatisticsF5.Request="    方程的非線性系統的大小：/P1";
DYNTranslationStatisticsF6.Request="    操作非線性系統后的大小：/P1";
DYNTranslationStatisticsF7.Request="    數值雅克比行列式的數量：/P1";
DYNTranslationStatisticsEnd.Request="";
DYNNonAssignedDiscrete.Request="以下實變量是用帶前綴的離散量聲明的，";
DYNNonAssignedDiscrete.Diagnostic="但是在 when 子句中未由賦值語句或方程賦值：\n/P1";
DYNRemovedExpandableConnectors1.Request="以下可擴展連接器變量未在模型中使用，";
DYNRemovedExpandableConnectors1.Diagnostic="并且已從模擬問題中移除：\n/P1";
DYNRemovedExpandableConnectors2.Request="以下可擴展連接器變量未在模型中使用，";
DYNRemovedExpandableConnectors2.Diagnostic="并且已從模擬問題中移除：\n/P1";
DYNRemovedConnectors1.Request="以下可擴展連接器變量未在模型中使用，";
DYNRemovedConnectors1.Diagnostic="并且已從模擬問題中移除：\n/P1";
DYNRemovedConnectors2.Request="以下可擴展連接器變量未在模型中使用，";
DYNRemovedConnectors2.Diagnostic="并且已從模擬問題中移除：\n/P1";
DYNKernelLogMessage_0187.Request="可視化數據分割：/P1 常量 /P2 時變";
DYNCheckComponentOKNonPhysicalAdvanced.Request="部件 /P1";
DYNCheckComponentOKNonPhysicalAdvanced.Diagnostic="僅當假定連接到非物理連接器強加合適的約束條件時才確定。非物理連接器：/P2";
DYNCheckCompleteNonPhysical.Request="檢查 /P1 已完成,";
DYNCheckCompleteNonPhysical.Diagnostic="假定連接到非物理連接器強加合適的約束條件。";
DYNCheckSucessfulNonPhysical.Request="已成功檢查 /P1,";
DYNCheckSucessfulNonPhysical.Diagnostic="假定連接到非物理連接器強加合適的約束條件。";
DYNCheckComponentOKNonPhysical.Request="部件 /P1";
DYNCheckComponentOKNonPhysical.Diagnostic="僅當假定連接到非物理連接器強加合適的約束條件時才確定。";
DYNNonPhysicalConnectorsLog.Request="非物理連接器：/P1";
DYNNoInlineIntegrationForHIL1.Request="實時模擬所需要的內聯集成。";
DYNNoInlineIntegrationForHIL2.Request="模型將在正常的模擬鏈接中運行，但是無法下載到實時平臺。";
DYNNotExportDynamicStateSelection.Request="不可能以動態狀態選擇導出模型。";
DYNNoLibraryExport.Request="沒有導出庫的許可證：/P1。";
DYNNotForPlatforms1.Request="沒有庫的導出許可證：/P1";
DYNNotForPlatforms2.Request="模型將在正常的模擬鏈接中運行，但是無法下載到實時平臺。";
DYNNoInlineIntegrationForDSPACE.Request="未找到子任務映射信息。";
DYNNoInlineIntegrationForDSPACE.Diagnostic="  本例中工作的 dSPACE 界面所需要的內聯集成！";
DYNContinuousSubtasksForDSPACE.Request="模型包含連續子任務。";
DYNContinuousSubtasksForDSPACE.Diagnostic="  本例中工作的 dSPACE 界面所需要的內聯集成！";
DYNDynamicStateSelectForDSPACE.Request="dSPACE 界面需要一組固定的狀態！";
DYNNoModelExport.Request="不可能導出模型。設置標識 Advanced。EnableCodeExport=true";
DYNFloatingBusConnErr.Request="為可展開連接器檢測到錯誤。";
DYNStreamConnErr.Request="為流式連接器檢測到錯誤。";
DYNStreamConnectorsLogIntroducedVars.Request="引入了支持流連接器的變量";
DYNStreamConnectorsLogIntroducedVars.Diagnostic="/P1";
DYNStreamConnectorsLogIntroducedEqus.Request="引入了支持流連接器的方程";
DYNStreamConnectorsLogIntroducedEqus.Diagnostic="/P1";
DYNOverdeterminedConnectorsIncomplete.Request="無法處理由過多因素確定的連接器。模型可能不完整。";
DYNOverdeterminedConnectorsPartial.Request="由于模型不完整，無法處理由過多因素確定的連接器。";
DYNOverdeterminedConnectorsBad.Request="處理多種因素確定的連接器出錯或失敗。";
DYNKernelLogMessage_0188.Request="已成功檢查 /P1。";
DYNExpansionBad.Request="展開向量或矩陣表達式出錯或失敗。";
DYNKernelLogMessage_0191.Request="已成功檢查 /P1。";
DYNExternalModificationBad.Request="外部修改出錯。";
DYNEquationBad.Request="處理方程結構出錯或失敗。";
DYNAutomatonBad.Request="將自動裝置變換到方程出錯或失敗。";
DYNFirstClockInferenceBad.Request="處理時鐘推理出錯或失敗。";
DYNDassaultAviationBad1.Request="處理時鐘推理出錯或失敗。";
DYNExportedDiscreteAsXML.Request="以 XML 方式導出離散時間部分。";
DYNMixedCintinuousDiscreteTimeInitialEquations.Request="跳過以下初始方程，因為它們引用了連續時間變量和離散時間變量";
DYNMixedCintinuousDiscreteTimeInitialEquations.Diagnostic="/P1";
DYNBothContAndDiscSepXML.Request="當前版本無法在同一平移中安排連續時間 FMU 和離散時間 FMU。";
DYNBothContAndDiscSepXML.Diagnostic="安排連續時間 FMU。";
DYNInitialEquDisabledSupport.Request="由于未啟用支持，初始方程被忽略";
DYNInitialEquDisabledSupport.Diagnostic="/P1";
DYNInternalLog6794.Request="用戶：/P1 大小：/P2，方程：/P3";
DYNExitErrorInWhen.Request="when 方程中檢測到錯誤。";
DYNExitFailedExpandAdvice1.Request="展開失敗可能是由于按以上指示方式假定的值， ";
DYNExitFailedExpandAdvice1.Diagnostic="如果在使用部件時給定了值，則這種情況不是錯誤。";
DYNExitFailedExpandAdvice2.Request="要避免此消息，請提供變量的最小值。";
DYNErrorsInModel.Request="模型中檢測到錯誤。";
DYNNonFixedStructureParameter1.Request="參數 /P1 將屬性固定為 = false";
DYNNonFixedStructureParameter1.Diagnostic="表示其值將從初始條件算出。";
DYNNonFixedStructureParameter2.Request="但是，它被用于指定結構屬性并且";
DYNNonFixedStructureParameter2.Diagnostic="必須能夠在平移時對其求值。";
DYNBadHighDers.Request="模型包括以下變量大于 1 階的導數";
DYNBadHighDers.Diagnostic="/P1\n，但是不予支持。";
DYNKernelLogMessage_0194.Request="DAE 帶有 /P1 個未知標量和 /P2 個標量方程。";
DYNKernelLogMessage_0195.Request="DAE 帶有 /P1 個未知標量和 /P2 個標量方程。";
DYNKernelLogMessage_0196.Request="檢查 /P1 時發現以上警告。";
DYNKernelLogMessage_0198.Request="檢查 /P1 時發現以上錯誤和警告。";
DYNKernelLogMessage_0200.Request="檢查 /P1 時發現以上錯誤。";
DYNKernelLogMessage_0202.Request="已成功檢查 /P1。";
DYNKernelLogMessage_0204.Request="DAE 帶有 /P1 個未知標量和 /P2 個標量方程。";
DYNKernelLogMessage_0205.Request="";
DYNKernelLogMessage_0206.Request="檢查 /P1 時發出了以上警告。";
DYNKernelLogMessage_0208.Request="已成功檢查 /P1。";
DYNKernelLogMessage_0210.Request="檢查 /P1 時發現以上錯誤。";
DYNKernelLogMessage_0212.Request="無法平移部分函數。";
DYNKernelLogMessage_0213.Request="無法平移沒有主體的函數。";
DYNKernelLogMessage_0214.Request="置亂應當保護以下頂層變量";
DYNKernelLogMessage_0215.Request="  /P1/P2/P3/P4";
DYNKernelLogMessage_0216.Request="無法使用加密模型對模型進行加密。";
DYNIndexReductionFailed.Request="未能減小 DAE 指數。";
DYNRealtimeMissingForInline.Request="實時模擬許可證選項要求使用內聯集成。";
DYNFastStatesBad.Request="向量 fastStates 有錯誤。";
DYNOscillationStatesBad.Request="向量 fastStates 有錯誤。";
DYNFailedFMI2FixedOrTunable.Request="以固定或可調方式對 FMI 進行參數排序失敗。";
DYNFailedToTranslateModelToFunction.Request="未能將模型平移到函數。";
DYNSubClockDecompositionFailed.Request="子時鐘分解失敗。";
DYNParallelizationFailed.Request="并行化分解失敗。";
DYNDSPACETaskingFailed.Request="對 dSPACE 進行任務屬性計算失敗。";
DYNClockInfoFailed.Request="生成時鐘信息失敗。";
DYNInternalAllocationFailure.Request="內部分配失敗。";
DYNFailed3dVisualize.Request="未能計算 3D 可視化的值。";
DYNKernelLogError_0093.Request="";
DYNKernelLogMessage_0217.Request="對于代碼生成 /P1";
DYNKernelLogMessage_0217.Diagnostic="非用戶（非平凡）方程：/P2\n用戶（含平凡）方程：/P3\n外部函數：/P4\n狀態：/P5（用戶 /P6)\n\n";
DYNHasDirectFeedThrough.Request="模型通過從輸入到輸出進行直接供給。";
DYNNoODEJacobianIncidence.Request="未能為 ODE 問題生成雅克比行列式的影響范圍。";
DYNNoBCDMatrices.Request="未能為輸入/輸出生成分析型雅克比行列式。";
DYNNoAnalyticODEJacobian.Request="未能為 ODE 問題生成分析型雅克比行列式。";
DYNFixedPointEnabled.Request="支持 FixedPoint.";
FixedPointMSG.Request="進行固定點分析時發現錯誤。代碼生成中止。";
DYNLicenseLog.Request="/P1";
DYNErrorDetectedWhenGeneratingCode.Request="生成代碼時檢測到錯誤。";
DYNNoAutomaticCompilation.Request="自動編譯已被用戶禁用。";
DYNUnknownDerivative.Request="尚未微分以下變量";
DYNUnknownDerivative.Diagnostic="  /P1";
DYNUnresolvedDerivative.Request="若不求解無法微分變量";
DYNUnresolvedDerivative.Diagnostic="  /P1";
DYNCannotDiffVar.Request="無法微分變量";
DYNCannotDiffVar.Diagnostic="  /P1";
DYNCannotDiffStringBoolean.Request="無法微分字符串或布爾值";
DYNCannotDiffStringBoolean.Diagnostic="  /P1";
DYNCannotDiffWRespect.Request="無法為";
DYNCannotDiffWRespect.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotDifferentiateInputWRespect.Request="無法微分輸入";
DYNCannotDifferentiateInputWRespect.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotDiffNonParSub.Request="無法微分";
DYNCannotDiffNonParSub.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNKernelLogError_0094.Request="記錄有內部錯誤，請向支持部分報告";
DYNCannotDiffDiscreteOrRecord.Request="無法微分離散變量或記錄變量";
DYNCannotDiffDiscreteOrRecord.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotDiffRecordOrArray.Request="無法微分記錄或數組";
DYNCannotDiffRecordOrArray.Diagnostic="  /P1\n 關于元素 /P2";
DYNCannotDiffBooleanValueWRespect.Request="無法微分布爾值";
DYNCannotDiffBooleanValueWRespect.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotDiffStringValueWRespect.Request="無法微分字符串值";
DYNCannotDiffStringValueWRespect.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotDiffBooleanExprWRespect.Request="無法微分布爾表達式";
DYNCannotDiffBooleanExprWRespect.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotDiffWhenClause.Request="無法微分 when 子句";
DYNCannotDiffWhenClause.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNAssumingContAtSwitch.Request="微分 /P1";
DYNAssumingContAtSwitch.Diagnostic="假定在轉換時連續。";
DYNCannotDiffListOfExpressions.Request="無法微分表達式列表";
DYNCannotDiffListOfExpressions.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotDiffForLoop.Request="尚未對具有從屬范圍的 for-loop 進行微分";
DYNCannotDiffForLoop.Diagnostic="  /P1";
DYNKernelLogMessage_0226.Request="變量不允許自動微分。";
DYNKernelLogMessage_0227.Request="/P1 無法求偏導數，因為未找到輸入。";
DYNKernelLogMessage_0228.Request="無法求變量 /P1 的偏導數。";
DYNCannotDiffNonSmoothWRespect.Request="表達式對求多次微分不夠平滑";
DYNCannotDiffNonSmoothWRespect.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotFindDerivative.Request="無法為函數求導";
DYNCannotFindDerivative.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotFindDiffFunc.Request="無法求微分函數";
DYNCannotFindDiffFunc.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotFindDerFor.Request="無法求導數";
DYNCannotFindDerFor.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotDifferentiateAlgorithms.Request="Dymola 當前無法區分算法。";
DYNCannotDifferentiateThisEquationClause.Request="尚未為此方程對時間求導。";
DYNCannotDifferentiateMultiWRec.Request="無法對具有多輸出（包括記錄）的函數進行微分";
DYNCannotDifferentiateMultiWRec.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotDifferentiateFuncRetBool.Request="無法微分返回布爾值的函數";
DYNCannotDifferentiateFuncRetBool.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotDifferentMultWSizeErr.Request="無法微分由于大小錯誤具有多個返回值的函數";
DYNCannotDifferentMultWSizeErr.Diagnostic="  /P1\n 關于 /P2 進行微分";
DYNCannotDiffArray.Request="尚未對數組進行微分";
DYNCannotDiffArray.Diagnostic="  /P1";
DYNCannotDifferentiateBooleanValue.Request="無法微分布爾值";
DYNCannotDifferentiateBooleanValue.Diagnostic="  /P1";
DYNCannotDifferentiateStringValue.Request="無法微分布爾值";
DYNCannotDifferentiateStringValue.Diagnostic="  /P1";
DYNCannotDiffBooleanExpr.Request="無法微分布爾表達式";
DYNCannotDiffBooleanExpr.Diagnostic="  /P1";
DYNCannotDifferentiateRecordExpression.Request="無法微分布爾表達式";
DYNCannotDifferentiateRecordExpression.Diagnostic="  /P1";
DYNCannotDifferentiateArrayExpression.Request="無法微分數組表達式";
DYNCannotDifferentiateArrayExpression.Diagnostic="  /P1";
DYNCannotDifferentiateAdvancedExpression.Request="無法微分高級表達式";
DYNCannotDifferentiateAdvancedExpression.Diagnostic="  /P1";
DYNCannotFindFunctionDerivative.Request="無法求函數的導數";
DYNCannotFindFunctionDerivative.Diagnostic="  /P1";
DYNCannotDiffNonSmooth.Request="表達式對求多次微分不夠平滑";
DYNCannotDiffNonSmooth.Diagnostic="  /P1";
DYNCannotDiffRecordFunction.Request="無法求返回記錄的函數的梯度";
DYNCannotDiffRecordFunction.Diagnostic="  /P1";
DYNNumericJacobian.Request="無法用數值計算方程式的梯度。";
DYNLogContextVariable.Request="對于變量 /P1";
DYNLocationDeclared.Request=" 中聲明 ";
DYNVariableNoLocation.Request=" 未知變量的。";
DYNVariableDefEquContext.Request="定義方程的類型不一致";
DYNVariableDefEquContext.Diagnostic="/P1";
DYNVariableStartValContext.Request="起始值類型不一致：/P1";
DYNVariableRecordBindingContext.Request="記錄綁定中的類型錯誤";
DYNVariableRecordBindingContext.Diagnostic="/P1";
DYNVariableSubscriptContext.Request="變量下標中的類型錯誤：1";
DYNEquContext0.Request="對于 /P1";
DYNEquContext.Request="對于方程";
DYNEquContext.Diagnostic="/P1";
DYNLocationEquFound.Request="查找范圍 ";
DYNKernelLogError_0095.Request="生成代碼時發生內部錯誤，請與支持人員聯系。";
DYNSIZEOfUnknownType.Request="未知類型表達式的大小表達式：/P1";
DYNZerSizeRecordUnsupported.Request="無法為大小是零的記錄變量 /P1 處理大小。";
UnsupportedZeroSizedConnector.Request="缺少對大小是零的連接器變量（帶有復雜的修飾符）/P1 的支持。";
UnsupportedZeroSizedVariable.Request="缺少對大小是零的記錄變量 /P1 的支持。";
DYNFailedSupportingRecords.Request="未提供對記錄的支持。";
DYNMemberSelInNonStructure.Request="嘗試選擇非結構化變量 /P2 中的成員 /P1。";
DYNRecordExprMissingMember.Request="記錄表達式 /P2 中找不到成員 /P1。";
DYNTooManyArrayIndices1.Request="數組表達式 /P1/P2/P3 的索引太多";
DYNTooManyArrayIndices1.Diagnostic="獲得 /P4 索引，但是只能使用 /P5。";
DYNIndexNonInteger.Request="數組表達式 /P2 的索引號 /P1 不是整數表達式。";
ArrayIndexExprBadType.Request="數組表達式 /P2 的索引號 /P1 既不是標量也不是向量。";
DYNSubscriptedNonArrayExpr.Request="/P1 中非數組表達式的下標。";
DYNTooManySubscripts.Request="/P1 中表達式的下標太多。";
DYNWrongNumberOfIndices.Request="/P1 中的索引數量不正確。";
DYNWrongNumberOfIndices1.Request="應當有 1 個索引。";
DYNWrongNumberOfIndices2.Request="應當有 /P1 個索引。";
DYNUnaryMinusOnNonNumeric.Request="否定表達式 /P1 的類型";
DYNUnaryMinusOnNonNumeric.Diagnostic="是 /P2，但是它必須是數值型。";
DYNNotArgNonBoolean.Request="否定表達式 /P1 的類型";
DYNNotArgNonBoolean.Diagnostic="是 /P2，但是它必須是布爾型。";
DYNEquSizeMismatch.Request="方程中的大小不匹配";
DYNEquSizeMismatch.Diagnostic="/P1";
DYNExprSizeMismatch.Request="表達式中的大小不匹配";
DYNExprSizeMismatch.Diagnostic="/P1";
DYNPossibleEquSizeMismatch.Request="方程中可能大小不匹配";
DYNPossibleEquSizeMismatch.Diagnostic="/P1";
DYNPossibleExprSizeMismatch.Request="表達式中可能大小不匹配";
DYNPossibleExprSizeMismatch.Diagnostic="/P1";
DYNBinOpSizeMismatch1.Request="左操作數的大小 /P1 是 /P2，右操作數的大小 /P3 是 /P4。";
DYNBinOpSizeMismatch2.Request="我們無法確定這些值相等。";
DYNFuncVect.Request="請注意函數調用";
DYNFuncVect.Diagnostic="由于以下參數，/P1\n 被向量化 /P2 次：";
DYNFuncVectArg1.Request="  參數 (/P1) = /P2";
DYNFuncVectArg2.Request="  /P1 = /P2";
DYNFuncVectArg3.Request="向量化引用的參數 /P1 不存在";
DYNUnEqualEquDimsScalarVector.Request="以下方程的左側是標量，";
DYNUnEqualEquDimsScalarVector.Diagnostic="右側是向量，即具有不兼容部分：\n/P1";
DYNUnEqualEquDimsScalarMatrix.Request="以下方程的左側是標量，";
DYNUnEqualEquDimsScalarMatrix.Diagnostic="右側是矩陣，即具有不兼容部分：\n/P1";
DYNUnEqualEquDimsScalarArray.Request="以下方程的左側是標量，";
DYNUnEqualEquDimsScalarArray.Diagnostic="右側是 /P1 維數組，即具有不兼容部分：\n/P2";
DYNUnEqualDimsScalarVector.Request="以下表達式的左側是標量，";
DYNUnEqualDimsScalarVector.Diagnostic="右側是向量，即具有不兼容部分：\n/P1";
DYNUnEqualDimsScalarMatrix.Request="以下表達式的左側是標量，";
DYNUnEqualDimsScalarMatrix.Diagnostic="右側是矩陣，即具有不兼容部分：\n/P1";
DYNUnEqualDimsScalarArray.Request="以下表達式的左側是標量，";
DYNUnEqualDimsScalarArray.Diagnostic="右側是 /P1 維數組，即具有不兼容部分：\n/P2";
DYNUnEqualEquDimsVecorScalar.Request="以下方程的左側是向量，";
DYNUnEqualEquDimsVecorScalar.Diagnostic="右側是標量，即具有不兼容部分：\n/P1";
DYNUnEqualEquDimsMatrixScalar.Request="以下方程的左側是矩陣，";
DYNUnEqualEquDimsMatrixScalar.Diagnostic="右側是標量，即具有不兼容部分：\n/P1";
DYNUnEqualEquDimsArrayScalar.Request="以下方程的左側是 /P1 維數組，";
DYNUnEqualEquDimsArrayScalar.Diagnostic="右側是標量，即具有不兼容部分：\n/P2";
DYNUnEqualDimsVectorScalar.Request="以下表達式的左側是向量，";
DYNUnEqualDimsVectorScalar.Diagnostic="右側是標量，即具有不兼容部分：\n/P1";
DYNUnEqualDimsMatrixScalar.Request="以下表達式的左側是矩陣，";
DYNUnEqualDimsMatrixScalar.Diagnostic="右側是標量，即具有不兼容部分：\n/P1";
DYNUnEqualDimsArrayScalar.Request="以下表達式的左側是 /P1 維數組，";
DYNUnEqualDimsArrayScalar.Diagnostic="右側是標量，即具有不兼容部分：\n/P2";
DYNIncompatibleBinOpDim.Request="以下部分";
DYNIncompatibleBinOpDim.Diagnostic="/P1\n 的維數是 /P2 和 /P3，但是它們必須相等。";
DYNBadScalarDims.Request="以下部分";
DYNBadScalarDims.Diagnostic="  /P1\n 的維數是 /P2 和 /P3，但是它們必須是標量";
DYNDeclaredVariable.Request="變量 /P1 聲明位置為 ";
DYNBinOpTypesNonCompatible.Request="/P1 中操作數的類型";
DYNBinOpTypesNonCompatible.Diagnostic="是 /P2 和 /P3，但是它們必須兼容。";
DYNBinOpTypesNonNumeric.Request="/P1 中操作數的類型";
DYNBinOpTypesNonNumeric.Diagnostic="是 /P2 和 /P3，但是它們必須是數值型。";
DYNBinOpTypesNonBoolean.Request="/P1 中操作數的類型";
DYNBinOpTypesNonBoolean.Diagnostic="是 /P2 和 /P3，但是它們必須是布爾型。";
DYNAnnotatedRecordNotFound.Request=" “未在其他項中找到”";
DYNAnnotatedRecordDimError.Request=" “尺寸數目不一致”";
DYNAnnotatedRecordIncompatible.Request=" “不兼容”";
DYNAnnotatedRecordNonAssignable.Request=" “不可分派”";
DYNAnnotatedType.Request="/P1/P2 /P3 /P4";
DYNAnnotatedRecordNL.Request="";
DYNAnnotatedRecordEnd.Request="/P1 結束 /P2/P3";
DYNAnnotatedRecordFinal.Request=";";
FailedToGenerateErrMessForNonCompRecs.Request="為非兼容記錄生成錯誤消息失敗。";
DYNIncompatibleRecordTypes.Request="以下變量中操作數的類型";
DYNIncompatibleRecordTypes.Diagnostic="  /P1\n 是不兼容記錄。";
DYNRealEquality.Request="/P1 中部分操作數的類型";
DYNRealEquality.Diagnostic=" 是 /P2 和 /P3。";
DYNRealEquality1.Request="無法為等式比較實數類型的變量。";
DYNRealEquality1.Diagnostic="接受它。";
DYNMultDimHigh.Request="部分...的維數";
DYNMultDimHigh.Diagnostic="  /P1\n 是 /P2 和 /P3";
DYNMultDimHigh1.Request="只為小于 3 的維數定義了乘法。";
DYNNonScalarDenominator.Request="的分母的維數";
DYNNonScalarDenominator.Diagnostic="  /P1\n 是 /P2。";
DYNNonScalarDenominator1.Request="分母必須是標量。";
DYNMatrixNotSquare.Request="/P1 必須是方陣，但是矩陣";
DYNMatrixNotSquare.Diagnostic="/P2\n 第一維的大小是 /P3，第二維的大小是 /P4。";
DYNMatrixNotSquareA.Request="它們不相等。";
DYNMatrixNotSquareB.Request="我們無法確定它們是否相等。";
DYNMatrixSquareNotMatrix.Request="需要一個方陣，但是未獲得矩陣";
DYNMatrixSquareNotMatrix.Diagnostic="/P1";
DYNNonScalarExponent.Request="的指數的維數";
DYNNonScalarExponent.Diagnostic="  /P1\n 是 /P2。";
DYNNonScalarExponent1.Request="指數必須是標量。";
DYNNonScalarPowBase.Request="的底數的維數";
DYNNonScalarPowBase.Diagnostic="  /P1\n 是 /P2。";
DYNNonScalarPowBase1.Request="底數必須是標量或方陣。";
DYNInternalSizeError.Request="/P1 的內部大小錯誤。";
DYNForExprNodeIteratorBadArg.Request="具有枚舉器的函數調用需要只有一個參數的函數";
DYNForExprNodeIteratorBadArg.Diagnostic="/P1";
DYNFailedForExprNode.Request="帶有枚舉器的表達式的表達式不正確。";
DYNIfThenElseConNonScalar.Request="if 語句 /P1 的條件中類型錯誤";
DYNIfThenElseConNonScalar1.Request="條件的維數是 /P1，但必須是標量。";
DYNIfThenElseConNonBoolean.Request="if 語句 /P1 的條件中類型錯誤";
DYNIfThenElseConNonBoolean1.Request="條件的類型是 /P1，但必須是布爾型表達式。";
DYNForIteratorNotVector.Request="枚舉器表達式 /P1 中的類型錯誤。";
DYNForIteratorNotVector.Diagnostic="第二個參數必須是向量，但是其維數是 /P2。";
DYNIteratorForProdMinMaxNotScalar.Request="具有乘積、最小值、最大值的枚舉器表達式不是 /P1 中的標量";
DYNUnknownFuncInIteratorExpr.Request="具有枚舉器 /P1 的表達式中未知的函數";
DYNCondBadType.Request="/P1 語句的條件中的類型錯誤";
DYNCondBadType.Diagnostic="/P1";
DYNCondBadType1.Request="條件的類型是 /P1，但是它必須是布爾表達式";
DYNCondBadDim.Request="/P1 語句：/P2 的條件中的類型錯誤";
DYNCondBadDim1.Request="條件的維數是 /P1，但必須是標量或向量。";
DYNCondBadDim2.Request="條件的維數是 /P1，但必須是標量。";
DYNWrongNumberOfCondArgs.Request="/P1/P2 的條件中參數個數不正確";
DYNLoopVarBad.Request="for 循環變量不是循環變量 /P1";
DYNForLoopIndicesBad.Request="for 語句 /P1 的循環索引中類型錯誤";
DYNForLoopIndicesBad1.Request="應當報告以上類型錯誤。";
DYNForLoopIndicesBad2.Request="循環索引的維數是 /P1，但是它必須是向量。";
DYNWhenCondTypeBad.Request="when 前綴中操作數的類型";
DYNWhenCondTypeBad.Diagnostic="  /P1\n 是 /P1，但是它必須是布爾型。";
DYNWhenCondTypeBad1.Request="when 是 /P1 的一個前綴。";
DYNUnsupportedWhenPrefix.Request="無法處理方程中的 /P1 子句。";
DYNUnsupportedWhenPrefix.Diagnostic="改為使用 if 表達式。";
DYNKernelLogMessage_0231.Request="記錄方程的非致命性內部錯誤。請向支持部門報告。";
DYNIncompatibleRecordAss.Request="不兼容記錄之間的賦值。";
DYNBadRecordAss.Request="將 /P1 賦值給 /P2。";
DYNMultiAssLHSNotExprList.Request="多重賦值需要表達式列表作為左側";
DYNMultiAssLHSNotExprList.Diagnostic="/P1";
DYNSingleExpression.Request="在模型中找到了單個表達式。";
DYNSingleExpression.Diagnostic="模型只可包含方程和賦值（以及過程調用）。";
DYNSingleExpression1.Request="多重賦值需要函數調用作為右側。";
DYNConnectNot2Args.Request="Connect 語句應當只有兩個參數。";
DYNConnectAndLHS.Request="Connect 語句是過程調用，沒有左側。";
DynConnectNotHandledCorrectly.Request="未正確處理 connect 語句，";
DynConnectNotHandledCorrectly.Diagnostic="請注意，算法部分中不可出現連接。";
DYNLogVariableNonScalarArg.Request="過程 LogVariable 只接受標量輸入。";
DYNLogVariableBadArgType.Request="過程 LogVariable 只接受數值和布爾值輸入。";
DYNLogVariableNotOneArg.Request="過程 LogVariable 接受一個變量作為輸入。";
MultiAssUnknownFunction.Request="只有已知的函數才可用作多重賦值中的右側。";
MultiAssUnknownProcedure.Request="只有已知的函數才可用作過程調用中的右側。";
DYNForCall.Request="對于調用：/P1";
DYNMultAssLHSNonRefs.Request="多重賦值的左側必須是部件引用。";
DYNTOOFewArgs.Request="參數太少";
DYNTOOFewArgs.Diagnostic="/P1\n至少應有 /P2 個參數。";
DYNWrongNumberOfArgs.Request="參數個數不正確";
DYNWrongNumberOfArgs.Diagnostic="/P1\n應當有 /P2 個參數。";
DYNWNumberOfArgsNotInrange.Request="參數個數不正確";
DYNWNumberOfArgsNotInrange.Diagnostic="/P1\n至少應有 /P2 個參數，至多有 /P3 個參數。";
DYNErrInArgA.Request="參數個數 /P1, /P2 = /P3，";
DYNErrInArgA.Diagnostic="/P4";
DYNErrInArgB.Request="參數個數 /P1, /P2 = /P3，";
DYNErrInArgB.Diagnostic="/P4";
DYNErrInArgC.Request="參數個數 /P1";
DYNErrInArgC.Diagnostic="/P2";
DYNErrInArgD.Request="...中的參數編號 /P1";
DYNErrInArgD.Diagnostic="/P2";
DYNMustBeScalar.Request="必須是標量。";
DYNMustBeVector.Request="必須是向量。";
DYNMustBeMatrix.Request="必須是矩陣。";
DYNMustBeArray.Request="必須是數組。";
DYNMustBeMultiDimensional.Request="必須是 /P1 維數組。";
DYNNonEqualFunctionArgDims.Request="變量";
DYNNonEqualFunctionArgDims.Diagnostic="/P1\n 中參數的維數是 /P2，根據需要它們不相等。";
DYNNonEqualFunctionArgDimsInRange.Request="參數起始個數 /P1 和上限個數";
DYNNonEqualFunctionArgDimsInRange.Diagnostic="/P2\n 中參數的維數是 /P3，根據需要它們不相等。";
DYNArgTypeBad.Request="屬于類型 /P1，但是它必須是 /P2 的子類型。";
DYNBadFunctionArgTypes.Request="變量";
DYNBadFunctionArgTypes.Diagnostic="/P1\n 中的參數屬于 /P2 類型，根據需要它們不兼容。";
DYNBadFunctionArgTypesInRange.Request="參數起始個數 /P1 和上限個數";
DYNBadFunctionArgTypesInRange.Diagnostic="/P2\n 中的參數屬于 /P3 類型，根據需要它們不兼容。";
DYNUnsupportedVectorization.Request="無法處理函數 /P1 的矢量化調用。";
DYNUnsupportedVectorization1.Request="參數 /P1 已矢量化，但是也用于大小表達式 /P2 中";
DYNUnknownVarInSizeExpr.Request="大小表達式 /P2 中的未知變量 /P1";
DYNUnknownVarInSizeExpr.Diagnostic="對于函數 /P3。";
DYNFunctionSizeError.Request="函數 /P1 的大小超出聲明部分 /P2 中的界限";
DYNSizeOfNonInput.Request="函數 /P1 的大小超出聲明部分 /P2 中的輸入范圍";
DYNFuncOutputHasColonSize.Request="輸出參數的大小使用函數調用中的：";
DYNFuncOutputHasColonSize.Diagnostic="/P1";
DYNMultipleOutputSize.Request="具有多個輸出的函數的大小：/P1";
DYNSizeMismatchInVectorization.Request="函數 /P1 作為以下變量進行調用的向量化中大小不匹配";
DYNSizeMismatchInVectorization.Diagnostic="/P2";
DYNPossibleSizeMismatchInVectorization.Request="函數 /P1 調用方式的向量化中可能大小不匹配";
DYNPossibleSizeMismatchInVectorization.Diagnostic="/P2";
DYNSizeMismatchInVectorization1.Request="參數 /P2 和 /P3 的大小 /P1 是 /P4 和 /P5。";
DYNSizeMismatchInVectorization1.Diagnostic="根據需要它們不相等。";
DYNKernelLogError_0098.Request="記錄的內部錯誤，請向支持部門報告。";
DYNFunctionBadOutputTypes.Request="函數調用 /P2 中輸出數值 /P1 屬于錯誤的類型。";
DYNFunctionBadOutputTypes1.Request="返回值屬于 /P1 類型，但必須是 /P2 的子類型。";
DYNFunctionBadOutputDims.Request="函數調用 /P2 中輸出數值 /P1 的維數不正確。";
DYNFunctionBadOutputDims1.Request="獲得的數組有 /P1 維，但期望的維數是 /P2。";
DYNMultipleAssignmentSizeMismatch.Request="多重賦值中大小不匹配";
DYNMultipleAssignmentSizeMismatch.Diagnostic="  /P1";
DYNMultipleAssignmentPossibleSizeMismatch.Request="多重賦值中可能大小不匹配";
DYNMultipleAssignmentPossibleSizeMismatch.Diagnostic="  /P1";
DYNMultipleAssignmentSizeMismatch1.Request="輸出數值 /P2 的大小 /P1 是 /P3，而函數調用的相應大小是 /P4";
DYNMultipleAssignmentSizeMismatch2.Request="我們無法確定這些大小是否相等。";
DYNFunctionNotProcedure.Request="函數 /P1 的調用過程，但是此函數已通過 /P2 輸出進行聲明。";
DYNFunctionNotProcedure.Diagnostic="在調用 /P3 中";
DYNFunctionMultiOutput.Request="函數 /P1 的正常函數調用，但是此函數已通過 /P2 輸出進行聲明。";
DYNFunctionMultiOutput.Diagnostic="多重輸出需要特殊語法：(output1,output2,..)=func(...).\n在調用中：/P3";
DYNFunctionMultiOutput1.Request="函數 /P1 的正常函數調用，但是此函數已通過 /P2 輸出進行聲明。";
DYNFunctionMultiOutput1.Diagnostic="在調用 /P3 中";
DYNFunctionWrongNumberOfOutputs.Request="/P1 的調用過程中輸出數量不正確。";
DYNFunctionWrongNumberOfOutputs.Diagnostic="期望 /P2 個，但是獲得了 /P3 個輸出。\n在調用中：/P4";
DYNFunctionUnknown.Request="找不到函數輸入正常參數";
DYNFunctionArguments.Request="函數輸入的類型不正確";
DYNFunctionWrongNumberOfArguments.Request="函數輸入非約束變量的數量不正確";
DYNFunctionInputBad.Request="函數輸入需要以函數作為參數";
DYNVectorizedCallBad.Request="無法使用函數 /P1 的向量化調用，因為它未返回單個標量。";
DYNIsInCall00.Request=" 在調用中是標量，在函數中是標量。";
DYNIsInCall01.Request=" 在調用中是標量，在函數中是向量。";
DYNIsInCall02.Request=" 在調用中是標量，在函數中是矩陣。";
DYNIsInCall0n.Request=" 在調用中是標量，在函數中是 /P1 維數組。";
DYNIsInCall10.Request=" 在調用中是向量，在函數中是標量。";
DYNIsInCall11.Request=" 在調用中是向量，在函數中是向量。";
DYNIsInCall12.Request=" 在調用中是向量，在函數中是矩陣。";
DYNIsInCall1n.Request=" 在調用中是向量，在函數中是 /P1 維數組。";
DYNIsInCall20.Request=" 在調用中是矩陣，在函數中是標量。";
DYNIsInCall21.Request=" 在調用中是矩陣，在函數中是向量。";
DYNIsInCall22.Request=" 在調用中是矩陣，在函數中是矩陣。";
DYNIsInCall2n.Request=" 在調用中是矩陣，在函數中是 /P1 維數組。";
DYNIsInCalln0.Request=" 在調用中是 /P1 維數組，在函數中是標量。";
DYNIsInCalln1.Request=" 在調用中是 /P1 維數組，在函數中是向量。";
DYNIsInCalln2.Request=" 在調用中是 /P1 維數組，在函數中是矩陣。";
DYNIsInCallnn.Request=" 在調用中是 /P1 維數組，在函數中是 /P2 維數組。";
DYNNonMatchingRecord.Request="不匹配記錄 ";
DYNCallWBadVectorization.Request="調用 /P1 過程中向量化不正確";
DYNCallWBadVectorization1.Request="每個向量化參數均必須增加相同數量的附加維數。";
DYNCallWBadVectorization2.Request="參數 /P1 增加了 /P2 維，但是參數 /P3 增加了 /P4 維";
DYNCallWBadVectorization2.Diagnostic="  /P5";
DYNKernelLogError_0099.Request="函數 /P1 的記錄輸出有內部錯誤。";
DYNArgNotAVariable.Request="/P1 的操作數必須是一個變量。";
DYNArgNotABooleanVariable.Request="/P1 中的操作數必須是一個布爾變量。";
DYNArgNotABooleanIntegerVariable.Request="/P1 中的操作數必須是一個布爾變量或整型變量。";
DYNIArgNotAVariable.Request="/P2 中的操作數 /P1 必須是一個變量。";
DYNIArgNotARealVariable.Request="/P2 中的操作數 /P1 必須是一個實型變量。";
DYNMustBeMatrixOrVector.Request="必須是矩陣（或向量）。";
DYNArgNotARealVariable.Request="/P1 中的操作數必須是一個實型變量。";
DYNArgNotARealExpr.Request="/P1 中的操作數必須是一個實數值表達式。";
DYNDiffOfInput.Request="不支持對輸入 /P1 進行微分。";
DYNDiffDiscreteTimeVar.Request="不支持對離散變量 /P1 進行微分。";
DYNDiffBadVariability.Request="不支持 /P1 /P2 的微分。";
DYNNoEventArgNotBool.Request="/P1 中的操作數必須是一個布爾表達式。";
DYNUnknownFuncRecordArg.Request="調用未知函數 /P2 中的 /P1 參數是...中的一個記錄";
DYNUnknownFuncRecordArg.Diagnostic="  /P3";
DYNReportConnectorSize1.Request="連接器有 /P1 個標量未知數。";
DYNReportConnectorSize2.Request="連接器有";
DYNReportConnectorSize2.Diagnostic="/P1\n 個標量未知數。";
DYNReportClassSize1.Request="它有 /P1 個標量未知數。";
DYNReportClassSize2.Request="它有";
DYNReportClassSize2.Diagnostic="/P1\n 個標量未知數。";
DYNReportModelSize1.Request="模型有 /P1 個標量未知數和 /P2 個標量方程。";
DYNReportModelSize2.Request="模型有";
DYNReportModelSize2.Diagnostic="/P1\n 個標量未知數和 \n/P2\n 個標量方程。";
DYNSizeErrorInBinding.Request="在約束方程中";
DYNSizeErrorInBinding.Diagnostic="/P1";
DYNSizeErrorInStartValueEquation.Request="在起始值方程中";
DYNSizeErrorInStartValueEquation.Diagnostic="/P1";
DYNSymbolicCheckAssumedDefault.Request="檢查假定";
DYNSymbolicCheckAssumedDefaultA.Request="  /P1 = /P2";
DYNSymbolicCheckAssumedDefaultB.Request="   ";
DYNLogPreEvalSizePars.Request="大小檢查可能使用了以下變量的值。";
DYNLogPreEvalSizePars.Diagnostic="/P1";
DYNSymbolicSizeCheckFailed.Request="變量的符號大小檢查失敗。";
DYNSizeConstraintDef.Request="  /P1 = /P2";
DYNSizeConstraintDef.Diagnostic="與定義 /P7 中出現的\n /P4\n 的 /P3 維以及\n /P6\n 的\n /P5 維有關";
DYNSizeConstraintEqu.Request="  /P1 = /P2";
DYNSizeConstraintEqu.Diagnostic="與方程 /P7 中出現的\n /P4\n 的 /P3 維以及\n /P6\n 的\n /P5 維有關";
SizeCheckFailed.Request="大小檢查失敗。";
DYNLoopInSizeConstraint.Request="大小約束條件中的循環";
DYNLoopInSizeConstraint1.Request="循環包含參數：+n/P1";
DYNSizeCondConstrainNotSymbolic.Request="無法推導以下條件性大小約束至以符號方式實現。";
DYNSizeConstrainNotSymbolic.Request="無法推導以下大小約束至以符號方式實現。";
DYNSizeConstraintReducesTo.Request="對于給定的參數設置，可將大小約束減小至";
DYNSizeConstraintReducesTo.Diagnostic="  /P1 = /P2";
FaultySizeConstraint.Request="錯誤的大小約束";
FaultySizeConstraint1.Request="可以將它減小至";
FaultySizeConstraint1.Diagnostic="  /P1 = /P2";
ProtectedParameterNotSet.Request="保護性參數沒有值集";
ProtectedParameterNotSet.Diagnostic="/P1";
DYNSizeCondTrueForValues.Request="但是，大小約束滿足參數的給定數值設置。";
DYNSizeCondTrueForBindings.Request="但是，大小約束滿足參數的給定界限。";
DYNSizeCountingLoop.Request="未知數和方程的個數導致代數循環。";
DYNEqualSizesForSettings.Request="無法將模型推導成用符號進行適定的表示。";
DYNEqualSizesForSettings.Diagnostic="",
"模型有\n  /P1\n 個標量未知數和\n  /P2\n 個標量方程。\n",
"對于參數的給定設置，\n可將差值減小至\n  /P3";
DYNNotBalancedModel.Request="模型具有的未知數和方程數量不同。";
DYNNotBalancedModel.Diagnostic="",
"模型有\n  /P1\n 個標量未知數和\n  /P2\n 個標量方程。\n",
"使用參數的給定設置，可將差值減小至\n  /P3";
DYNBalancedModelError.Request="模型不適定。";
DYNBalancedModelError.Diagnostic="",
"模型有\n  /P1\n 個標量未知數和\n  /P2\n 個標量方程。\n",
"使用參數的給定設置，可將差值減小至\n  /P3";
DYNBalancedNonPhysicalRelax.Request="但是，連接至非物理連接器可強加合適的約束條件。";
DYNBalancedNonPhysicalRelax.Diagnostic=" 非物理連接器：\n/P1";
DYNProtectedParNotSet.Request="保護性參數沒有值集";
DYNSizesOKForSettings0.Request="模型具有的未知數和方程數量相同";
DYNSizesOKForSettings0.Diagnostic="對于參數的給定數值設置。";
DYNSizesOKForSettings.Request="模型具有的未知數和方程數量相同";
DYNSizesOKForSettings.Diagnostic="對于參數的給定數值設置：/P1";
DYNEqualSizesForNumericSettings1.Request="無法將模型推導成用符號進行適定的表示。";
DYNEqualSizesForNumericSettings1.Diagnostic="",
"模型有\n  /P1\n 個標量未知數和\n  /P2\n 個標量方程。\n",
"但是，利用參數的給定數值設置，可提供相同數量的未知數和方程：\n  /P3";
DYNSizesOKForBindings0.Request="模型具有的未知數和方程數量相同";
DYNSizesOKForBindings0.Diagnostic="對于參數的給定界限。";
DYNSizesOKForBindings2.Request="模型具有的未知數和方程數量相同";
DYNSizesOKForBindings2.Diagnostic="對于參數的給定界限：\n  /P1";
DYNEqualSizesForGivenBindings.Request="無法將模型推導成用符號進行適定的表示。";
DYNEqualSizesForGivenBindings.Diagnostic="",
"模型有\n  /P1\n 個標量未知數和\n  /P2\n 個標量方程。\n",
"但是，利用給定的邊界參數，可提供相同數量的未知數和方程：\n  /P3";
DYNEqualSizesOKAlways0Comp.Request="模型部件 /P1 具有的未知數和方程數量相同。";
DYNEqualSizesOKAlways0.Request="模型具有的未知數和方程數量相同。";
DYNEqualSizesOKAlways1.Request="模型具有的未知數和方程數量相同：/P1";
DYNEqualSizesOKAlways2.Request="模型具有的未知數和方程數量相同";
DYNEqualSizesOKAlways2.Diagnostic="  /P1";
DYNEqualSizesOKAlways3.Request="模型具有的未知數和方程的符號數量相同。";
DYNKernelLogWarning_0025.Request="警告：查找 /P1 /P2 發現保護元素 /P3。";
DYNKernelLogError_0100.Request="錯誤：導入 /P1 的查找失敗";
DYNKernelLogWarning_0026.Request="警告：重復導入 /P1 至范圍 /P2 中。";
DYNKernelLogError_0101.Request="錯誤：模糊導入 /P1 至范圍 /P2 中。";
DYNKernelLogMessage_0232.Request="首先由 /P1 發現 ";
DYNKernelLogMessage_0233.Request="然后由 /P1 發現 ";
DYNKernelLogError_0102.Request="模糊導入 /P1 至范圍 /P2 中。";
DYNKernelLogMessage_0234.Request="首先由導入 /P1 發現。*";
DYNKernelLogMessage_0235.Request="然后由 /P1 發現。*";
DYNKernelLogWarning_0027.Request="警告：/P1 的封裝";
DYNKernelLogWarning_0027.Diagnostic="  防止我們在范圍 /P3 中找到 /P2。\n";
DYNKernelLogWarning_0028.Request="警告：在范圍 /P2 中找到 /P1 時交叉封裝邊界。";
DYNKernelLogWarning_0029.Request="警告：/P1 的封裝";
DYNKernelLogWarning_0029.Diagnostic=" 防止我們在全局范圍中找到 /P2。\n";
DYNKernelLogError_0103.Request="錯誤：Dymola 的當前版本無法推導 for 循環的索引。";
DYNKernelLogMessage_0236.Request="對記錄進行算術運算時遇到問題。";
DYNKernelLogMessage_0237.Request="產生于調用 /P1，此調用使用函數 /P2。";
DYNKernelLogError_0104.Request="錯誤：用 () 而不是 [] 為變量 /P1 加下標。";
DYNKernelLogError_0105.Request="類型中或全局范圍中發現的變量必須是常量，但是 /P1 不是。";
DYNKernelLogError_0106.Request="全局常量的實例化很可能進入循環。";
DYNKernelLogWarning_0030.Request="全局常量 /P1";
DYNKernelLogWarning_0030.Diagnostic=" 是 (/P2=/P3)，該值小于它的最小值 (/P4=/P5)。";
DYNKernelLogWarning_0031.Request="全局常量 /P1";
DYNKernelLogWarning_0031.Diagnostic=" 是 (/P2)，該值小于它的最小值 (/P3)。";
DYNKernelLogWarning_0032.Request="全局常量 /P1";
DYNKernelLogWarning_0032.Diagnostic=" 是 (/P2=/P3)，該值大于它的最大值 (/P4=/P5)。";
DYNKernelLogWarning_0033.Request="全局常量 /P1";
DYNKernelLogWarning_0033.Diagnostic=" 是 (/P2)，該值大于它的最大值 (/P3)。";
DYNKernelLogError_0107.Request="函數中使用的全局記錄必須有值，但是沒有找到 /P1 的任何值。";
DYNKernelLogError_0108.Request="函數中使用的全局記錄必須有值，但是沒有找到 /P1 的任何值。";
DYNKernelLogError_0109.Request="變量 /P1 在聲明前使用";
DYNKernelLogError_0110.Request="使用未聲明的變量 /P1";
DYNKernelLogMessage_0238.Request="注意：處理全局變量很可能進入 /P1 的循環。";
DYNKernelLogError_0111.Request="錯誤：在類型或全局變量中找到的變量必須是常量，但是 /P1 不是。";
DYNKernelLogError_0112.Request="錯誤：找不到枚舉成員 /P1";
DYNKernelLogWarning_0034.Request="警告（接受非法代碼）";
DYNKernelLogWarning_0034.Diagnostic="  部件 /P1 已受保護，因此不應從外部訪問。\n";
DYNKernelLogMessage_0239.Request="全名：/P1";
DYNKernelLogMessage_0240.Request="故障：在全局范圍中找到使用外部 /P1";
DYNKernelLogError_0113.Request="解析枚舉器表達式時出錯，無法繼續。";
DYNKernelLogError_0114.Request="解析枚舉器表達式時出錯，無法繼續。";
DYNKernelLogError_0115.Request="對于帶有枚舉器的表達式，尚不支持自動扣減范圍。";
DYNKernelLogError_0116.Request="錯誤：對于記錄構建器 /P2，尚不支持基礎類 /P1";
DYNKernelLogMessage_0241.Request=" 在 /P1 中";
DYNKernelLogMessage_0242.Request=" (/P1 ";
DYNKernelLogMessage_0243.Request=")";
DYNKernelLogMessage_0244.Request="/P1";
DYNKernelLogMessage_0245.Request="/P1";
DYNKernelLogError_0120.Request="函數的位置參數太多 ";
DYNKernelLogError_0117.Request="錯誤：以前的錯誤妨礙類型檢查。";
DYNKernelLogError_0118.Request="函數有未知名稱的參數 '/P1' ";
DYNKernelLogError_0119.Request="在調用函數時，已命名的參數 '/P1' 已經有值 ";
DYNKernelLogError_0121.Request="內部錯誤：輸入的數量與函數 /P1 中輸入的默認值之間不匹配。";
DYNKernelLogError_0121.Diagnostic="",
"請向支持部門報告。\n";
DYNKernelLogError_0122.Request="錯誤：默認的參數處理可能循環函數 /P1。";
DYNKernelLogError_0123.Request="當函數中出錯時，無法處理 /P1 的默認參數 ";
DYNKernelLogError_0124.Request="在調用函數時必須為參數 '/P1' 提供值 ";
DYNKernelLogError_prototype0020.Request="未知的操作符或函數 /P1";
DYNKernelLogError_0126.Request="部件數組的內部錯誤。請向支持部門報告。";
DYNKernelLogError_0127.Request="內部錯誤，缺少 DAE！請向支持部門報告。";
DYNKernelLogError_0128.Request="部件的數組錯誤：修改放 (=/P1) 和被修改方對維數持不同看法。";
DYNKernelLogError_0129.Request="部件的數組錯誤：修改放 (=/P1) 和被修改方對維數持不同看法。";
DYNKernelLogError_0130.Request="內部錯誤，缺少變量！請向支持部門報告。";
DYNKernelLogError_0131.Request="類 /P1 繼承自 ExternalObject，但是不滿足外部對象的要求。";
DYNKernelLogOperator_1.Request="錯誤：通過部件 /P2 調用運算符 /P1 不合法。";
DYNKernelLogError_overloadNamedFunc.Request="錯誤：用枚舉器無法調用可能過載的函數 /P1。";
DYNKernelLogError_overloadNamed.Request="錯誤：用枚舉器無法調用可能過載的構建器 /P1。";
DYNKernelLogError_overloadNamedString.Request="錯誤：用枚舉器無法調用可能過載的字符串。";
DYNKernelLogError_0132.Request="聲明外部對象類型 /P1 的析構器出錯。";
DYNKernelLogError_0132.Diagnostic="它應當有 1 個輸入和 0 個輸出。\n";
DYNKernelLogError_0133.Request="聲明外部對象類型 /P1 的構建器出錯。";
DYNKernelLogError_0133.Diagnostic="它應當有 1 個輸出。\n";
DYNKernelLogError_0134.Request="嘗試調用非函數對象 ";
DYNKernelLogError_0135.Request="函數 /P1 未知";
DYNKernelLogWarning_0035.Request="展開失敗 ";
DYNKernelLogWarning_0036.Request="發現函數 /P1 無顯式聲明";
DYNKernelLogError_0136.Request="命名的參數必須位于未知參數后。";
DYNKernelLogError_0136.Diagnostic="",
"對于函數則不是這種情況 ";
DYNKernelLogError_0137.Request="調用函數時，枚舉器必須位于最后。";
DYNKernelLogError_0137.Diagnostic="",
"對于函數則不是這種情況 ";
DYNKernelLogError_0138.Request="混合枚舉器和命名的參數。";
DYNKernelLogError_0138.Diagnostic="",
"對于函數 ";
DYNKernelLogMessage_0248.Request="在調用 /P1(/P2) 中";
DYNKernelLogError_0139.Request="未知函數 /P1";
DYNKernelLogMessage_0250.Request="沒有為記錄的數組指定大小 /P1。在使用模型前必須指定。";
DYNKernelLogMessage_0251a.Request="在類 /P1 中。";
DYNKernelLogMessage_0251b.Request="應用于類 /P1 的修飾符。";
DYNKernelLogMessage_0251c.Request="在類 /P1 中找到的變量。";
DYNKernelLogMessage_0253a.Request="在 /P1 中使用。";
DYNKernelLogMessage_0253b.Request="應用于 /P1 的修飾符。";
DYNKernelLogMessage_0253c.Request="在 /P1 中發現的變量。";
DYNKernelLogMessage_0254a.Request="在部件 /P1 中使用。";
DYNKernelLogMessage_0254b.Request="應用于部件 /P1 的修飾符。";
DYNKernelLogMessage_0254c.Request="在部件 /P1 中發現的變量。";
DYNInternalErrorToExpand.Request="待擴大的內部故障";
DYNInternalErrorToExpand.Diagnostic="  /P1";
DYNMissingRecordElementHetArray.Request="在異構數組可能引起展開后，找不到記錄元素 /P1。";
DYNMissingRecordElementCondDecl.Request="找不到記錄元素 /P1 可能是由于異構數組以及條件聲明。";
DYNWrongNumberOfIndices.Request="/P1 中的索引數量不正確。";
DYNWrongNumberOfIndices0.Request="變量是標量。";
DYNWrongNumberOfIndices1.Request="變量是向量。";
DYNWrongNumberOfIndices2.Request="變量是矩陣。";
DYNWrongNumberOfIndicesn.Request="變量有 /P1 維。";
DYNIndexOutOfRange.Request="/P2 的索引 /P1 是 /P3，超出了 1 至 /P4 的范圍。";
DYNFailedToExpand.Request="未能展開 /P1。";
DYNFailedEvaluateIndex.Request="未能算出 /P2 的索引 /P1";
DYNMissingRecordElementHetArrayAtExpandDetetceted.Request="在展開 /P1 檢測，找不到展開的記錄元素 /P2，可能是異構數組引起。";
DYNMissingRecordElement.Request="變量 /P1 在 /P2 中不存在。";
DYNIndexOutsideRange.Request="/P1 中合法范圍以外的索引。";
DYNNotOpNonScalar.Request="無法投射...的參數";
DYNNotOpNonScalar.Diagnostic="  /P1\n 至一個標量值。";
DYNPartsNotScalars.Request="部分";
DYNPartsNotScalars.Diagnostic="  /P1\n 無法投射到標量：/P2 和 /P3";
DYNIncompatibeSizes.Request="部分";
DYNIncompatibeSizes.Diagnostic="/P1\n 的大小不兼容：/P2 和 /P3。";
DYNLoopVarError.Request="檢測到 /P1 = /P2 的錯誤";
DYNLoopVarError.Diagnostic="/P3";
DYNUnableToExpandForStatement.Request="無法展開 for 語句";
DYNUnableToExpandForStatement.Diagnostic="/P1\n因為它不可能展開循環索引。";
DYNUnableToExpandIfEquation.Request="無法展開 if 語句";
DYNUnableToExpandIfEquation.Diagnostic="/P1";
DYNUnableToExpandIfEquationA1.Request="因為它不是以 else 子句結束。";
DYNUnableToExpandIfEquationA2.Request="即使在邏輯上已列舉了所有可能性，if 語句也必須以 else 子句結束。";
DYNUnableToExpandIfEquationA3.Request="除非：條件是可以求值的參數";
DYNUnableToExpandIfEquationA3.Diagnostic="或者“方程”已聲明或具有相似的結構。";
DYNUnableToExpandIfEquationB1.Request="由于它不可能將所有方程展開成標量方程。";
DYNUnableToExpandIfEquationB2.Request="Dymola 當前版本只能處理以下情況的 if 語句：";
DYNUnableToExpandIfEquationB2.Diagnostic="  1. 條件是可以求值的參數表達式\n  2. 所有分支中的左側變量均為同一變量\n  3. 方程可以展開成標量實數方程\n  4. 以上情況的組合\n  5. 只有在由可以求值的參數表達式控制的情況下，才支持 when 語句。";
DYNUnableToExpandIfEquationC1.Request="由于不同的分支具有不同數量的方程。";
DYNUnableToExpandIfEquationC2.Request="當條件是非參數類型時的 if 語句";
DYNUnableToExpandIfEquationC2.Diagnostic="所有分支必須與相同數量的標量方程。";
DYNUnsupportedUseOfDefineBranch.Request="嵌套使用 defineBranch、defineRoot 或 definePotentialRoot 不受支持";
DYNUnsupportedUseOfDefineBranch.Diagnostic="/P1";
DYnUnsupportedElseWhen.Request="方程中不支持 elsewhen";
DYnUnsupportedElseWhen.Diagnostic="/P1";
DYNWhenWithinWhen.Request="when 子句內部不允許有 when 子句";
DYNWhenWithinWhen.Diagnostic="/P1";
DYNUnableToExpandWhen.Request="無法展開 when 語句";
DYNUnableToExpandWhen.Diagnostic="/P1\n因為不可能展開這些部分。";
DYNWhenConditionBadType.Request="when 條件屬于 /P1 類型";
DYNForClauseNotVector.Request="for 子句表達式";
DYNForClauseNotVector.Diagnostic="/P1\n 不是向量表達式。";
DYNNestedWhen.Request="嵌套 when 子句于";
DYNNestedWhen.Diagnostic="  /P1";
DYNNonScalarIfCondition.Request="無法將變量的條件投射 ";
DYNNonScalarIfCondition.Diagnostic="/P1\n 到標量值。";
DYNFailedToExpandIterator.Request="無法展開枚舉器表達式的數組";
DYNFailedToExpandIterator.Diagnostic="/P1\n 不支持未展開的枚舉器表達式。";
DYNIteratorBadZero.Request="不支持帶 /P1 的過載的零枚舉器表達式";
DYNIteratorBad.Request="不支持帶 /P1 的枚舉器表達式";
DYNBadScalarProduct.Request="標量積";
DYNBadScalarProduct.Diagnostic="  /P1\n 具有不同大小的向量：/P2 和 /P3";
DYNBadMatrixVecProduct.Request="矩陣與向量的積中大小不兼容";
DYNBadMatrixVecProduct.Diagnostic="  /P1";
DYNBadMatrixVecProduct1.Request="矩陣有 /P1 列，向量有 /P2 元素。";
DYNBadVecMatrixProduct.Request="向量與矩陣的積中大小不兼容";
DYNBadVecMatrixProduct.Diagnostic="  /P1";
DYNBadVecMatrixProduct1.Request="向量有 /P1 個元素，矩陣有 /P2 行。";
DYNMatrixMultBadSizes.Request="矩陣與矩陣的乘積中大小不兼容";
DYNMatrixMultBadSizes.Diagnostic="/P1\n第一個矩陣有 /P2 列，第二個矩陣有 /P3 行。";
DYNCannotCastDenominatorToScalar.Request="無法將";
DYNCannotCastDenominatorToScalar.Diagnostic="  /P1\n 的分母投射至一個標量值。";
DYNNegMatrixExponent.Request="矩陣乘方中的負指數";
DYNNegMatrixExponent.Diagnostic="  /P1";
DYNFunctionOnlyInScripts.Request="只能從腳本中使用函數 /P1。";
DYNExpandFuncFailed.Request="缺少對函數展開的支持";
DYNExpandFuncFailed.Diagnostic="  /P1";
DYNVectorizationSizeMismatch.Request="函數 /P1 作為以下變量進行調用的向量化中大小不匹配";
DYNVectorizationSizeMismatch.Diagnostic="/P2";
DYNVectorizationSizeMismatch1.Request="參數 /P2 和 /P3 的大小 /P1 是：/P4 和 /P5。";
DYNVectorizationSizeMismatch2.Request="根據需要它們不相等。";
DYNIllegalCastToScalar.Request="非法投射至標量";
DYNIllegalCastToScalar.Diagnostic="/P1";
DYNIllegalCastToVector.Request="非法投射至向量";
DYNIllegalCastToVector.Diagnostic="/P1";
DYNIllegalCastToMatrix.Request="非法投射至矩陣";
DYNIllegalCastToMatrix.Diagnostic="/P1";
DYNNonEqualSizes.Request="部分";
DYNNonEqualSizes.Diagnostic="/P1\n 的大小不相等：\n /P2";
DYNFailedCalcRangeArg1.Request="未能計算...的第一個參數";
DYNFailedCalcRangeArg1.Diagnostic="  /P1";
DYNFailedCalcRangeArg2.Request="未能計算...的第二個參數";
DYNFailedCalcRangeArg2.Diagnostic="  /P1";
DYNFailedCalcRangeArg3.Request="未能計算...的最后參數";
DYNFailedCalcRangeArg3.Diagnostic="  /P1";
DYNZeroRangeStep.Request="...的第二個參數（步長） ";
DYNZeroRangeStep.Diagnostic="/P1\n 值為 0。";
DYNFailedEvalLinspace3Arg.Request="未能求出...的第三個參數";
DYNFailedEvalLinspace3Arg.Diagnostic="  /P1";
DYNBadLinspace3arg.Request="第三個參數必須是大于 /P1 的整數";
DYNMatrixBuildFailure.Request="嘗試構建矩陣：/P1";
DYNMatrixBuildFailure.Diagnostic="其中的參數 /P2 無法展開。";
DYNArrayDiagonalArgNotVector.Request="參數必須是向量：/P1";
DYNFailedEvalIdentityArg.Request="未能求出標識的參數";
DYNFailedEvalIdentityArg.Diagnostic="  /P1";
DYNFailedEvalFillSizeArg.Request="未能求出大小的值";
DYNFailedEvalFillSizeArg.Diagnostic="  /P1\n 的\n  /P1";
DYNNegFillSizes.Request="負數大小";
DYNNegFillSizes.Diagnostic="  /P1\n大小是：/P2";
DYNTransposeNonMatrix.Request="轉置需要矩陣";
DYNTransposeNonMatrix.Diagnostic="  /P1";
DYNBadSkewArgSize.Request="參數必須是大小為 3 的向量表達式";
DYNBadSkewArgSize.Diagnostic="  /P1";
DYNBadCrossArg1.Request="第一個參數必須是大小為 3 的向量表達式";
DYNBadCrossArg1.Diagnostic="  /P1";
DYNBadCrossArg2.Request="第二個參數必須是大小為 3 的向量表達式";
DYNBadCrossArg2.Diagnostic="  /P1";
DYNFailedToHandleDer.Request="未能處理導數表達式 /P1";
DYNFailedEvaluateCatArg1.Request="未能求出...的第一個參數";
DYNFailedEvaluateCatArg1.Diagnostic="  /P1";
DYNNegCatArg1.Request="CAT 的第一個參數必須 > 0";
DYNNegCatArg1.Diagnostic="  /P1";
DYNHighCatDimA.Request="CAT 維數太高";
DYNHighCatDimA.Diagnostic="  /P3 中的 /P1\n = /P2\n，其中數組參數有 /P4 維。";
DYNHighCatDimB.Request="CAT 維數太高";
DYNHighCatDimB.Diagnostic="  /P2\n 中的 /P1\n，其中數組參數具有 /P3 維。";
DYNArrayConcatenateFailure.Request="嘗試連接數組：/P1";
DYNArrayConcatenateFailure.Diagnostic="此處無法展開參數 /P2。";
IncompatibleCatParts.Request="在";
IncompatibleCatParts.Diagnostic="  /P1 中要連接的部分大小不兼容：\n/P2";
DYNConcatenateNothing.Request="嘗試連接空內容 /P1";
DYNKernelLogMessage_0256.Request="錯誤：可能遞歸定義了字符串變量 /P1";
DYNKernelLogMessage_0257.Request="求出結構參數的值（從 /P1）/P2 = /P3；";
DYNKernelLogWarning_0037.Request="警告：Dymola 無法處理具有不相等元素的數組。";
DYNKernelLogWarning_0038.Request="警告：非字面值。";
DYNKernelLogWarning_0039.Request="警告：類型錯誤。";
DYNVariableAndDefEquExpandFailed.Request="未能展開變量 /P1";
DYNVariableAndDefEquExpandFailed.Diagnostic="及其定義方程：\n/P2";
DYNVariableExpandFailed.Request="未能展開變量 /P1";
DYNInConcealedPart.Request="隱式部分中的問題。";
DynStartValueExpandError1.Request="未能展開起始值";
DynStartValueExpandError1.Diagnostic="  變量 /P2\n 的 /P1";
DynStartValueExpandError2.Request="未能展開變量 /P1 可能丟失的起始值";
DYNFailedCheckSizeDecl.Request="未能求值并檢查維數 /P2 的大小聲明 /P1，";
DYNFailedCheckSizeDecl.Diagnostic="其定義方程或起始值\n要求的大小為 /P3。";
DYNIncompatibleVarDefStartSizes.Request="變量 /P1 的大小";
DYNIncompatibleVarDefStartSizes.Diagnostic="及其定義方程或起始值不兼容。";
DYNIncompatibleVarDefStartSizes1.Request="對于維數 /P1，其大小 /P2 和 /P3 不兼容。";
DYNMissingSubscipts.Request="/P2 缺少下標 /P1";
DYNVariableSubscripts.Request="變量 /P2 的聲明中的下標 /P1 既不是參數也不是常量表達式。";
DYNNegVarSizes.Request="變量 /P1 的大小為負值。";
DYNNegVarSizes.Diagnostic="對于維數 /P2，大小是 /P3。";
DYNIncompatibleVarAndDefEquSizes.Request="變量及其定義方程的維數不兼容";
DYNIncompatibleVarAndDefEquSizes.Diagnostic="/P1 = /P2";
DYNIncompatibleVarDefEquSizes1.Request="變量及其定義方程的大小不兼容；";
DYNIncompatibleVarDefEquSizes1.Diagnostic="  /P1 = /P2";
DYNIncompatibleVarDefEquSizes2.Request="它們的維數是 /P1，大小是 /P2 和 /P3。";
DYNIncompatibleVarStartDimsA.Request="變量及其起始值的維數不兼容";
DYNIncompatibleVarStartDimsA.Diagnostic="  /P1 = /P2";
DYNIncompatibleVarStartDimsB.Request="變量 /P1 及其起始值的維數不兼容。";
DYNLocationDeclaredIn.Request="...中已聲明 ";
DYNIncompatibleVarStartSizes1A.Request="變量及其起始值的大小不兼容；";
DYNIncompatibleVarStartSizes1A.Diagnostic="  /P1 = /P2";
DYNIncompatibleVarStartSizes2.Request="它們的維數是 /P1，大小是 /P2 和 /P3。";
DYNIncompatibleVarStartSizes1B.Request="變量及其起始值的大小不兼容；";
DYNIncompatibleVarStartSizes1B.Diagnostic="  /P1";
DYNKernelLogError_0140.Request="記錄有內部錯誤，請向支持部分報告";
DYNFailureHetArrayAndCondParts.Request="未能為由條件刪除變量形成的異構數組展開。";
DYNUnsupportedZeroRecordArray.Request="不支持記錄的大小為零的數組：/P1";
DYNConflictingCausality.Request="/P1 (/P2) 及其元素 /P3(/P4) 的因果關系沖突";
DYNExternalInNonFunc.Request="函數中可能出現外部子句。";
DYNEquWInvalidExpr.Request="方程中的表達式無效";
DYNEquWInvalidExpr.Diagnostic="/P1";
DYNUnknownEquType.Request="未知方程";
DYNUnknownEquType.Diagnostic="/P1";
DYNResolveVariableRemove.Request=" 已有條件地移除自聲明 /P2 以來的 /P1";
DYNResolveVariable.Request=" /P1";
DYNResolveError1.Request="未聲明的變量";
DYNResolveError.Request="未聲明的變量";
DYNResolveErrorOther.Request="解析錯誤：/P1)";
DYNResolveSubscript.Request="在 /P1 聲明中";
DYNResolveDefinition.Request="在定義方程式中";
DYNResolveDefinition.Diagnostic=" /P1 = /P2\n";
DYNResolveAlgoritm.Request="在 ";
DYNResolveAlgoritm.Diagnostic=" /P1\n";
DYNResolveEquation.Request="在方程式中";
DYNResolveEquation.Diagnostic=" /P1\n";
DYNWarnUnreferencedVars.Request="未引用的變量";
DYNWarnUnreferencedVars.Diagnostic="&1";
DYNKernelLogMessage_0258.Request="錯誤：不受支持：Dymola 的當前版本無法刪除代碼";
DYNKernelLogMessage_0258.Diagnostic="",
"為算法中記錄數組的數組索引\n";
DYNKernelLogError_0141.Request="錯誤：不受支持：Dymola 的當前版本無法刪除代碼";
DYNKernelLogError_0141.Diagnostic="",
"為此數組左側的索引。\n";
DYNKernelLogError_0142.Request="錯誤：不受支持：Dymola 的當前本版不支持";
DYNKernelLogError_0142.Diagnostic="",
"記錄表達式的可變數組索引。\n";
DYNKernelLogError_0143.Request="內部錯誤：未能展開字符串。";
DYNKernelLogError_0144.Request="錯誤：WriteAsMatrix 檢測到內部錯誤：dsmodel.c 中有更多信息。";
DYNKernelLogError_0145.Request="錯誤：WriteAsMatrix 中有內部錯誤。";
DYNKernelLogWarning_0040.Request="不受支持：使用函數中未知大小的記錄的數組。";
DYNKernelLogWarning_0040.Diagnostic="",
"dsmodel.c 中尚未支持，如果在模型中調用此函數，將會失敗。\n";
DYNKernelLogError_0146.Request="錯誤：無法為記錄未知大小的數組生成 C 語言代碼。";
DYNKernelLogError_0148.Request="記錄的數組出錯。";
DYNKernelLogWarning_0041.Request="不受支持：使用函數中未知大小的記錄的數組。";
DYNKernelLogWarning_0041.Diagnostic="",
"dsmodel.c 中尚未支持，如果在模型中調用此函數，將會失敗。\n";
DYNKernelLogError_0149.Request="錯誤：無法為記錄未知大小的數組生成 C 語言代碼。";
DYNKernelLogWarning_Slicing.Request="不受支持：左側分割。";
DYNKernelLogError_0150.Request="內部錯誤：與函數中的 for 表達式有關。";
DYNKernelLogError_0151.Request="錯誤：無法處理帶有枚舉器的未展開表達式。";
DYNKernelLogError_0152.Request="錯誤：嘗試在 /P2 內部生成 /P1";
DYNKernelLogError_0152.Diagnostic="這將不會獲得預期結果。\n";
DYNNuSMVFunctionSkip.Request="函數調用 /P1 已被替換為 NuSMV 的代碼中的 false。";
DYNKernelLogError_0153.Request="為 /P1 生成代碼時出現內部錯誤";
DYNKernelLogError_0154.Request="錯誤：未能為算法中的 /P1 生成代碼";
DYNKernelLogError_0155.Request="錯誤：無法使用已使用的函數。";
DYNKernelLogError_0156.Request="錯誤：當前版本無法發送非文字字符串至未知函數 /P1。";
DYNKernelLogError_0157.Request="錯誤：內部錯誤：向未知函數 /P1 發送記錄";
DYNKernelLogError_0157.Diagnostic=" - 直到生成代碼才檢測。\n";
DYNRemovedRedundantInitialConditions.Request="刪除以下冗余且相容的初始方程：/P1";
DYNTMissingInitWarning.Request="  未完全指定初始條件。";
DYNTMissingInitWarning.Diagnostic="    Dymola 已選擇默認的初始條件。";
DYNTranslationStatisticsB10.Request="    LogDefaultInitialConditions = true; 提供更多信息。";
DYNSortTotalInitProblemfailed.Request="所有初始問題看來成為異常問題";
DYNFailedSelectingInitDefaults.Request="未能選擇非異常的初始條件默認值。";
DYNFailedSelectingInitDefaults.Diagnostic="提供顯式初始條件。";
DYNKernelLogMessage_0259.Request="帶有 /P1 /P2 的字符串問題";
DYNIncompleteInitConditions.Request="屬于類型 /P1 的變量的初始條件未完全指定。";
DYNUseFixedContStateStart.Request="假定連續狀態的固定起始值。";
DYNUseFixedContStateStart.Diagnostic="/P1";
DYNUseFixedContStateStartDefault.Request="假定連續狀態的固定默認起始值";
DYNUseFixedContStateStartDefault.Diagnostic="/P1";
DYNUseInitZeroDerivative.Request="假定導數為零";
DYNUseInitZeroDerivative.Diagnostic="/P1";
DYNUseFixedDiscStateStart.Request="假定離散狀態的固定起始值";
DYNUseFixedDiscStateStart.Diagnostic="/P1";
DYNUseFixedDiscStateStartDefault.Request="假定離散狀態的固定默認起始值";
DYNUseFixedDiscStateStartDefault.Diagnostic="/P1";
DYNUseFixedDiscNonStateStart.Request="假定非離散狀態的固定起始值";
DYNUseFixedDiscNonStateStart.Diagnostic="/P1";
DYNUseFixedDiscNonStateStartDefault.Request="假定非離散狀態的固定默認起始值";
DYNUseFixedDiscNonStateStartDefault.Diagnostic="/P1";
DYNOverspecInitProblem.Request="為元素類型 /P1.的變量過多指定了初始化問題。";
DYNOverspecInitProblemNoUnknownEqus1.Request="初始方程 ";
DYNOverspecInitProblemNoUnknownEqus1.Diagnostic="/P1 引用所有已知變量。\n要更正它，您可以刪除此方程或 \n/P2 非活動的起始值";
DYNOverspecInitProblemNoUnknownEqus2.Request="初始方程 ";
DYNOverspecInitProblemNoUnknownEqus2.Diagnostic="/P1 引用所有已知變量。\n要更正它，您可以刪除此方程";
DYNOverspecInitProblemNoUnknownEqus3.Request="方程 ";
DYNOverspecInitProblemNoUnknownEqus3.Diagnostic="/P1 引用所有已知變量。\n要更正它，您可以刪除此方程或 \n/P2 非活動的起始值";
DYNOverspecInitProblemNoUnknownEqus4.Request="方程 ";
DYNOverspecInitProblemNoUnknownEqus4.Diagnostic="/P1 引用所有已知變量。這可能說明模擬問題也是異常問題。";
DYNOverspecInitProblem1.Request="有 /P1 個過多的標量條件。";
DYNOverspecInitProblem2.Request="要更正它，您可以";
DYNOverspecInitProblem2A.Request="  非活動的起始值";
DYNOverspecInitProblem2A.Diagnostic="/P1/P2";
DYNOverspecInitProblem2B.Request="  刪除初始方程：/P1";
DYNOverspecInitProblem2BAdvanced.Request="  刪除初始條件";
DYNEquation.Request="/P1";
DYNEquationDerivedFrom.Request="  來自于";
DYNEquationDerivedFrom.Diagnostic="/P1";
DYNMissingInitNoRecover.Request="未完全指定初始條件。";
DYNMissingInitNoRecover.Diagnostic="很遺憾通過假定狀態的起始值無法完成它們。缺少 /P1 個標量條件。\n無法單獨決定以下變量 \n/P2";
DYNCannotDifferentiateThisEquationClause.Request="尚未為此方程對時間求導。";
DYNKernelLogError_0158.Request="內部錯誤：矩陣在此處只能有一個元素。";
DYNKernelLogError_0159.Request="內部錯誤：矩陣在此處只能有一個元素。";
DYNForResidual.Request="對于殘差";
DYNForRecordResidual.Request="對于記錄殘差";
DYNForArrayResidual.Request="殘差數組不一致";
DYNKernelLogMessage_0260.Request="/P1 聯立方程組的線性系統已進行符號求解。";
DYNKernelLogMessage_0261.Request="自動分割 /P1 聯立方程組的線性系統";
DYNKernelLogMessage_0262.Request="為 /P1 方程的線性系統給出數值解。";
DYNKernelLogMessage_0263.Request="/P1 聯立方程組的線性系統，";
DYNKernelLogMessage_0264.Request="自動分割 /P1 聯立方程組的非線性系統，";
DYNKernelLogMessage_0265.Request="已選擇 /P1 個迭代變量。";
DYNKernelLogMessage_0266.Request="/P1 聯立方程組的非線性系統，";
DYNKernelLogWarning_0042.Request="警告：內部錯誤：在雅可比行列式中發現 /P1 個新交叉函數。";
DYNKernelLogWarning_0042.Diagnostic="",
"不應發生這種情況，模擬速度可能會下降。";
DYNKernelLogMessage_0270.Request="自動分割 /P1 聯立方程組的非線性系統，";
DYNKernelLogMessage_0271.Request="已選擇 /P1 個迭代變量。";
DYNKernelLogMessage_0272.Request="/P1 聯立方程組的非線性系統，";
DYNKernelLogMessage_0273.Request="自動分割 /P1 聯立方程組的非線性系統，";
DYNKernelLogMessage_0274.Request="已選擇 /P1 個迭代變量。";
DYNKernelLogMessage_0275.Request="/P1 聯立方程組的非線性系統，";
DYNKernelLogMessage_0276.Request="/P1 迭代變量有非線性問題";
DYNKernelLogMessage_0277.Request="引用 /P1 參數 ";
DYNKernelLogMessage_0278.Request="/P1";
DYNKernelLogMessage_0279.Request="引用 /P1 依賴于時間的變量。";
DYNKernelLogMessage_0280.Request="/P1";
DYNKernelLogWarning_0043.Request="警告：內部錯誤：在雅可比行列式中發現 /P1 個新交叉函數。";
DYNKernelLogWarning_0043.Diagnostic="",
"不應發生這種情況，模擬速度可能會下降。";
DYNKernelLogWarning_0044.Request="未知的隱式方法：/p1";
DYNKernelLogWarning_0044b.Request="未知的顯式方法 /P1";
DYNKernelLogError_0160.Request="錯誤：不支持：分割記錄中的整型數組不受支持。";
DYNDSPACEOutputError.Request="為 dSPACE 界面生成代碼出錯。";
DYNInitialReinit.Request="有重新初始化語句作為初始化方程";
DYNInitialReinit.Diagnostic="/P1";
DYNInitialReinit2.Request="初始方程不合法。";
DYNFailedGenSimCode.Request="無法生成模擬代碼。";
DYNTranslationAborted.Request="平移中止。";
DYNExitFuncErr.Request="函數中檢測到錯誤。";
DYNResolveError.Request="未聲明的變量或命令：/P1";
DYNResolveTimeFunction.Request="無法在函數中使用時間。";
DYNResolveTimeGlobal.Request="無法在全局范圍中使用時間。";
DYNResolveWhen.Request="When 在函數中非法";
DYNResolveWhen.Diagnostic=" /P1";
DYNFunctionRenameDeprecated.Request="將棄用的函數 /P1 自動重命名為合法的 Modelica 名稱 /P2。";
DYNFunctionUnknown.Request="未聲明的函數 /P1。";
DYNFunctionCannotUse.Request="在函數中，非法使用函數：/P1";
DYNFailedCodeGenForSingleNonLin.Request="當前版本無法生成求解實變量的代碼";
DYNFailedCodeGenForSingleNonLin.Diagnostic="  從非線性方程式\n  /P2 求解實際變量  /P1";
DYNFailedCodeGenForSingleNonReal.Request="當前版本無法生成代碼，以";
DYNFailedCodeGenForSingleNonReal.Diagnostic="  從方程式：\n  /P2 求解非實際變量 /P1\n";
DYNFailedCodeGenForAlgLoopWhen.Request="無法為";
DYNFailedCodeGenForAlgLoopWhen.Diagnostic="涉及 when 方程式或算法和 when 零件的代數環生成代碼。\n未知量：\n/P1\n方程式：\n/P2";
DYNFailedCodeGenForAlgLoopWhen1.Request="您可以切斷環， ";
DYNFailedCodeGenForAlgLoopWhen1.Diagnostic="方法是將 \"pre\" 放置在\nwhen 零件或 when 條件中未知連續時間變量的一些參考周圍。";
DYNNotSupportingDynamicStateSelection1.Request="抱歉，Dymola 無法固定選擇狀態，";
DYNNotSupportingDynamicStateSelection1.Diagnostic="但在模擬期間已準備好動態選擇狀態。";
DYNNotSupportingDynamicStateSelection2.Request="您可以嘗試以下方法";
DYNNotSupportingDynamicStateSelection3.Request="1. 在 Dymola 和模擬模式中，在轉換前，";
DYNNotSupportingDynamicStateSelection3A.Request="   選擇“模擬設置”，選取“轉換”，并 ";
DYNNotSupportingDynamicStateSelection3A.Diagnostic="   勾選“評估參數以減少模型”和“列出選定的連續狀態”。";
DYNNotSupportingDynamicStateSelection3B.Request="   轉換和檢查轉換日志，并查看 Dymola 選擇";
DYNNotSupportingDynamicStateSelection3B.Diagnostic="   作為狀態的項，以及它是否為固定集。";
DYNNotSupportingDynamicStateSelection4.Request="2. Modelica 允許用戶控制狀態選擇。";
DYNNotSupportingDynamicStateSelection4A.Request="   您可以強制變量成為一種狀態，方法是將其";
DYNNotSupportingDynamicStateSelection4A.Diagnostic="   stateSelect 屬性設為 StateSelect.always。";
DYNNotSupportingDynamicStateSelection4B.Request="   通常，您可以在轉換時記錄選定的狀態。";
DYNNotSupportingDynamicStateSelection4C.Request="   選擇“實驗設置”，選取“轉換”，勾選“列出選定的連續狀態”。";
DYNNotSupportingDynamicStateSelection4D.Request="   您可以在模擬期間記錄動態選擇狀態的結果。";
DYNNotSupportingDynamicStateSelection4E.Request="   選擇“實驗設置”，選取“調試”，勾選“動態選擇狀態”。";
DYNNotSupportingDynamicStateSelection4F.Request="   希望此日志可協助您進行固定選擇。";
DYNNotSupportingDynamicStateSelection4G.Request="   如果 Dymola 能夠對";
DYNNotSupportingDynamicStateSelection4G.Diagnostic="   剩余狀態進行固定選擇，則部分選擇可用。";
DYNNotSupportingDynamicStateSelection4H.Request="   請注意，Dymola 不支持單獨設置";
DYNNotSupportingDynamicStateSelection4H.Diagnostic="   數組元素的 stateSelect 屬性。";
DYNInlineIntegrationNotFixedStates.Request="內聯集成方法假定固定的狀態集。";
DYNExportNotFixedStates.Request="只有假定固定的狀態集時，才能導出模型。";
DYNExportNotFixedStates.Diagnostic="模型將在 Dymola 中作為常規模型運行。";
DYNSimulinkNotFixedStates.Request="Simulink 中的 Dymola 塊假定固定的狀態集。";
DYNSimulinkRealTimeNotFixedStates.Request="Simulink 中實時平臺的 Dymola 塊假定固定的狀態集。";
DYNSimulinkRealTimeNotFixedStates.Diagnostic="模型將在常規 Simulink 中運行，但無法下載至實時平臺。";
DYNKernelLogMessage_0291.Request="模型已聲明模式變量，但自動找到其他模式變量。";
DYNKernelLogMessage_0292.Request="模式值將僅用于模型中聲明的模式變量。";
DYNFailedCodeGenOccured.Request="為代數環生成代碼時，未能生成代碼。";
DYNFailedGradient.Request="無法計算梯度";
DYNFailedGradient.Diagnostic="  /P1";
DYNFailedFunctionGradientNonRealInput.Request="無法計算非實輸入";
DYNFailedFunctionGradientNonRealInput.Diagnostic="  /P1 至非標量函數 /P2 的梯度";
DYNFailedGradientForEqu.Request="只能計算未知函數的非標量梯度，而不能用于 ";
DYNFailedGradientForEqu.Diagnostic="  /P1";
DYNFailedGradientForFunction1.Request="只能計算指定導數的函數的非標量梯度，而不能用于";
DYNFailedGradientForFunction1.Diagnostic="  /P1";
DYNFailedGradientForFunction2.Request="無法使用導數計算非標量函數的梯度（通常無法使用高階導數）";
DYNFailedGradientForFunction2.Diagnostic="  /P1";
DYNFailedNonScalarEquationGradient.Request="如果左側為簡單變量，則只能計算非標量梯度，而不能用于";
DYNFailedNonScalarEquationGradient.Diagnostic="  /P1";
DYNFailedJacobianForLinearSystem.Request="無法區分 Jacobian 的線性子系統。";
DYNNoJacobianFailedDiffMultRet.Request="系統沒有 Jacobian，因為無法區分多重返回函數";
DYNNoJacobianFailedDiffMultRet.Diagnostic="  /P1";
DYNNoJacobianFailedDiffAlgo.Request="系統沒有 Jacobian，因為無法區分算法";
DYNNoJacobianFailedDiffAlgo.Diagnostic="  /P1";
DYNNoJacobianFailedDiffDynStateSel.Request="系統沒有 Jacobian，因為無法區分含有動態狀態選擇的模型。";
DYNNoJacobianFailedDiffUnknown.Request="系統沒有 Jacobian，因為無法區分";
DYNNoJacobianFailedDiffUnknown.Diagnostic="  /P1";
DYNNoJacobianSizeMismatch.Request="系統沒有 Jacobian，因為大小不匹配。";
DYNNoJacobianFailedSomeEqu.Request="系統沒有 Jacobian，因為無法區分部分方程式。";
DYNKernelLogWarning_0045.Request="警告：內部錯誤：Jacobian 中發現 /P1 新交叉函數。";
DYNKernelLogWarning_0045.Diagnostic="",
"不應出現此問題；模擬速度可能減慢。";
DYNCircularEqualities.Request="檢測到圓等式。";
DYNCircularEqualities1.Request="方程式 ";
DYNEquation.Request="/P1";
DYNEquationDerivedFrom.Request="  派生自";
DYNEquationDerivedFrom.Diagnostic="/P1";
DYNCircularEqualities2.Request="指以下變量的圓等式：";
DYNCircularEqualities2.Diagnostic="/P1";
DYNModelHint.Request="模型包括以下提示";
DYNModelHint.Diagnostic="/P1";
DYNSkippingStartVal.Request="跳過 /P1 = /P2 的起始值";
DYNSkippingStartVal.Diagnostic="并使用 /P3 = /P4";
DYNRemovedAdditionalEqu.Request="移除其他一致的方程式";
DYNInconsistentEqu.Request="不一致的方程式";
DYNAdditionaLog1.Request="模型指定";
DYNAdditionaLog1.Diagnostic="  /P1 = /P2\n  /P3 = /P4";
DYNAdditionaLog2.Request="不過，模型也會明確或間接指定";
DYNAdditionaLog2.Diagnostic="  /P1 = /P2/P3";
DYNAliasEliminationFailed.Request="無法消除別名變量。";
DYNRemovedStringEqu.Request="冗余一致的字符串方程式已移除";
DYNRemovedBoolEqu.Request="冗余一致的布爾方程式已移除";
DYNRemovedIntegerEqu.Request="冗余一致的整數方程式已移除";
DYNRemovedReal_Equ.Request="冗余一致的實方程式已移除";
DYNRedEquInconsistent.Request="找到冗余不一致的方程式";
DYNKernelLogMessage_0298.Request="/P1 簡易方程式已消除。";
DYNKernelLogError_0161.Request="內部錯誤：構造變量時，記錄中缺少部件 /P1。";
DYNKernelLogError_0162.Request="錯誤：抱歉，Dymola 的當前版本無法處理非函數中的",
"非字面字符串 /P1。";
DYNKernelLogError_0163.Request="錯誤：抱歉，Dymola 的當前版本無法處理模型中的字符串變量：/P1";
DYNKernelLogError_0164.Request="錯誤：為數組 /P1 生成代碼時發生內部錯誤，請報告錯誤。";
DYNKernelLogMessage_0299.Request="生成代碼時發生內部錯誤";
DYNKernelLogMessage_0299.Diagnostic="",
"  此錯誤可能因依據以下規定屬非法的模型所致：\n",
"    Modelica 規范第 3.1.1.2 條 靜態名稱查找：\n",
"     “如果第一個標識符表示部件，則\n",
"     在部件聲明的命名部件元素中查找其余名稱。”\n",
"  使用函數的界限“參數”代替“輸入”也可能導致此錯誤。\n";
DYNAutomaticEach.Request="在變量的定義方程式中自動引入“每個”";
DYNAutomaticEach.Diagnostic="  /P1";
DYNAutomaticEach1.Request="不會寫入此類型的其他警告。";
DYNDefEquVariabilityBad.Request="定義方程式的可變性";
DYNDefEquVariabilityBad.Diagnostic="/P1大于變量聲明的可變性。";
DYNConstantNoValue.Request="變量 /P1";
DYNConstantNoValue.Diagnostic="聲明為常量，但未賦予值。";
DYNStartValueBadDim.Request="變量 /P1 具有 /P2 個尺寸，但起始值具有 /P3 個尺寸。";
DYNStartValueBadType.Request="變量 /P1 含有元素類型 /P2，但起始值含有不兼容的類型 /P3。";
DYNStartValNonparameter.Request="變量";
DYNStartValNonparameter.Diagnostic="  /P1\n含有的起始值并非參數表達式：\n  /P2";
DYNStartValNonparameter1.Request="起始值指派未排序，";
DYNStartValNonparameter1.Diagnostic="表示變量可能無法按預期初始化\n，且生成的 dsmodel.c 可能無法編譯。";
DYNVariableSubscriptContextNotInteger.Request="數組變量的下標 /P1 并非整數。";
DYNVariableSubscripts.Request="變量 /P2 聲明中的下標 /P1 既不是參數，也不是常量表達式。";
DYNDimErrorWhenSettingVar.Request="設置數組時數字尺寸不匹配";
DYNDimErrorWhenSettingVar.Diagnostic="  /P1";
DYNKernelLogError_0165.Request="記錄中存在內部錯誤，請向支持人員報告。";
DYNKernelLogError_0166.Request="記錄中存在內部錯誤，請向 Dynasim 報告";
DYNKernelLogError_0167.Request="記錄中存在內部錯誤，請向 Dynasim 報告";
DYNRecordLacksMember.Request="記錄 /P1 缺少成員 /P2。";
DYNCloneFailed.Request="對函數、參數 /P1 求值失敗。";
DYNFuncInputBadSize.Request="函數輸入 /P2 的尺寸 /P1 具有聲明大小 /P3，而輸入大小 /P4。";
DYNExecuteFuncArrayRecordsDimsBad.Request="執行函數時出錯：記錄數組 /P1 具有 /P2 個尺寸，而值含有 /P3 個";
DYNExecuteFuncArrayRecordsSizeBad.Request="執行函數時出錯：記錄數組 /P1 具有大小(/P2)=/P3，而值 /P4 含有大小 /P5。";
DYNExecuteFuncArrayRecordsSizeNotPosInteger.Request="執行函數時出錯：記錄數組 /P1 下標 /P2 為并非正整數的 /P3。";
DYNKernelLogError_0170.Request="錯誤：內部錯誤：記錄中無法找到變量 /P1。";
DYNKernelLogError_0171.Request="錯誤：內部錯誤。";
DYNKernelLogError_0172.Request="錯誤：內部錯誤：數組中無法找到變量 /P1。";
DYNSizeOfUnknownVariableType.Request="未知類型變量的大小表達式：/P1";
DYNCheckAssumedDefault.Request="檢查假設：/P1 = /P2";
DYNKernelLogWarning_0046.Request="警告：方程式中的非亂置記錄“/P1” 替換為記錄構造函數";
DYNKernelLogWarning_0046.Diagnostic="",
"（例如，通過函數調用指定）。\n",
"為避免出現此警告，請將\n",
"輸出 /P2 /P3=f(...);\n替換為\n輸出 /P4 /P5=/P6_dummy;\n  保護 /P7 /P8_dummy=f(...);\n";
DYNKernelLogWarning_0047.Request="警告：方程式中的非亂置記錄“/P1” 替換為記錄構造函數";
DYNKernelLogWarning_0047.Diagnostic="",
"（例如，通過函數調用指定或輸入至函數調用）。\n",
"為避免出現此警告，請將\n",
"  /P2 /P3\n方程式\n  .../P4...\n替換為\n /P5 /P6;\n保護 /P7 /P8_dummy=/P9;\n方程式\n  ... /P10_dummy...\n";
DYNFixedPointInternalError.Request="定點中存在內部錯誤。";
DYNFixedPointErrorMissingMinMaxResolution.Request="未設置 /P1 的最小值、最大值和分辨率";
DYNFixedPointErrorMissingMinMax.Request="未設置 /P1 的最小值和最大值";
DYNFixedPointWarningAppearingArray.Request="數組變量 /P1 發生未知內部錯誤";
DYNFixedPointErrorArray.Request="定點不支持數組。";
DYNFixedPointMustSetResolutionState.Request="必須為狀態變量設置分辨率、最小值和最大值：/P1";
DYNFixedPointMustSetResolutionVar.Request="必須為變量設置分辨率、最小值和最大值：/P1";
DYNFixedPointErrorConveringLiteral.Request="將字面值轉換為定點時出錯。";
DYNFixedPointErrorMultireturning.Request="定點不支持多重返回方程式。";
DYNFixedPointErrorAlgorithm.Request="定點不支持算法截面。";
DYNFixedPointInternalErrorNoVariable.Request="與查找變量相關的定點內部錯誤：/P1";
DYNFixedPointInternalErrorNoExpression.Request="與查找表達式相關的定點內部錯誤：/P1";
DYNFixedPointErrorResolution.Request="/P1 的值無法以指定的分辨率表示。";
DYNFixedPointErrorResolution1.Request="   最小值/最大值/分辨率 = /P1// 3951 校正官方漢化P2// 3951 校正官方漢化P3 時最小可表示的值為 /P4，";
DYNFixedPointErrorResolution2.Request="   而 /P1 的值為 /P2";
DYNFixedPointErrorTooSmall.Request="/P1 的求解值小于指定的最小值。";
DYNFixedPointErrorTooBig.Request="/P1 的求解值大于指定的最小值。";
DYNFixedPointArrayError.Request="定期代碼生成不支持布爾數組。";
DYNFixedPointErrorExternalInitial.Request="定點在外部目標上不支持函數 initial()。";
DYNFixedPointErrorExternalSample.Request="定點在外部目標上不支持函數 sample()";
DYNFixedPointInternalErrorExternalFunction.Request="外部函數發生定點內部錯誤。";
DYNFixedPointReducedPrecisionForAdd.Request="對加法移位會降低表達式的精度：/P1";
DYNOverflowdescription1.Request="     /P1:   Q[/P2, /P3]";
DYNOverflowdescription2Plus.Request="     對齊二進制點得出：Q[/P1, /P2] << /P3 + Q[/P4, /P5] << /P6 = Q[/P7, /P8]";
DYNFixedPointReducedPrecisionForSub.Request="對減法移位會降低表達式的精度：/P1";
DYNOverflowdescription2Minus.Request="     對齊二進制點得出：Q[/P1, /P2] << /P3 - Q[/P4, /P5] << /P6 = Q[/P7, /P8]";
DYNFixedPointErrorPossibleDivisionByZero.Request="/P1 的區間 [最小值, 最大值] 包含 0，這是不允許的，因為它在以下項中用作分母：";
DYNFixedPointErrorPossibleDivisionByZero.Diagnostic="/P2";
DYNFixedPointErrorPower.Request="定點不支持冪函數。";
DYNFixedPointErrorOverflow.Request="移位導致定點溢出。";
DYNFixedPointErrorForExpression.Request="定點不支持 for 表達式。";
DYNFixedPointErrorCodeGenerationForLoops.Request="定點不支持為 for-loops 生成代碼。";
DYNFixedPointWarning.Request="定點找到 when 塊。";
DYNFixedPointWarningCodeGenerationWhenBlock.Request="定點為 when 塊生成代碼。";
DYNFixedPointErrorMultiInputFunctions.Request="定點不支持含多個輸入的函數。";
DYNKernelLogWarning_0048.Request="";
DYNKernelLogError_0173.Request="";
DYNKernelLogWarning_0049.Request="";
DYNEndFuncArgError.Request="特殊函數 \"end\" 不接受任何參數";
DYNFailedExpaningEnd.Request="無法展開特殊函數 \"end\"";
DYNKernelLogError_0174.Request="錯誤，并非所有 \"end\" 都能展開。";
DYNBreakFuncErr.Request="特殊函數 break 不接受任何參數";
DYNReturnFuncErr.Request="特殊函數 return 不接受任何參數";
DYNMinMaxFailure.Request="不支持展開函數 /P1";
DYNSizeMismatchInCall.Request="在調用 /P1 時大小不匹配：/P2";
DYNSizePossibleMismatchInCall.Request="在調用 /P1 時可能大小不匹配：/P2";
DYNSizeMismatchInCall1.Request="第一個參數的大小 /P1 為 /P2，而第二個參數的大小為 /P3。";
DYNSizeMismatchInCall1.Diagnostic="兩者不相等。";
DYNKernelLogWarning_0050.Request="不支持：在函數中使用未知大小的記錄數組。";
DYNKernelLogWarning_0050.Diagnostic="",
"dsmodel.c 尚不支持此操作，如果在此模型中調用，此函數將會失敗。\n";
DYNKernelLogError_0175.Request="錯誤：不支持未知大小的記錄數組。";
DYNKernelLogWarning_0051.Request="警告：大小(...)中的循環依賴項";
DYNSizeFuncFailure.Request="無法計算 /P1 的第二個參數";
DYNSizeFuncErrOutOfBound.Request="/P1 的第二個參數含有值 /P2。";
DYNSizeFuncErrOutOfBound.Diagnostic="它必須大于零且小于等于 /P3，它是第一個參數的維度。";
DYNVectorFuncBadDims.Request="函數向量要求最多一個尺寸具有非單位大小";
DYNVectorFuncBadDims.Diagnostic="  /P1";
DYNVectorFuncBadDims1.Request="我們無法確定情況是否如此。";
DYNMatrixFuncBadDims.Request="矩陣要求在調用中 size(A,i)=1 for i>2：/P1";
DYNMatrixFuncBadDims1A.Request="但大小 /P1 為不等于 1 的 /P2。";
DYNMatrixFuncBadDims1B.Request="但大小 /P1 為可能不等于 1 的 /P2。";
DYNMustBeMatrixOrVector.Request="必須為矩陣或具有較高維度。";
DYNMatrixAsVectorBad.Request="Dymola 兼容性：將矩陣視為向量要求表達式中矩陣最多只有一個非 1 尺寸";
DYNMatrixAsVectorBad.Diagnostic="  /P1\n其大小為：/P2";
DYNCrossArgsNotVector3.Request="函數 cross 在調用中需要將 3 個向量作為輸入：/P1";
DYNCrossArgsNotVector3.Diagnostic="但參數數目 /P2 的長度為 /P3。";
DYNCrossArgsNotVector3A.Request="我們無法確定此項是否等于 3。";
DYNSkewArgsNotVector3.Request="函數 skew 在調用中需要將 3 個向量作為輸入：/P1";
DYNSkewArgsNotVector3.Diagnostic="但參數的長度為 /P2。";
DYNSkewArgsNotVector3A.Request="我們無法確定此項是否等于 3。";
DYNSizeMismatchInCallOfArray.Request="在調用 /P1 時大小不匹配：/P2";
DYNSizePossibleMismatchInCallOfArray.Request="在調用 /P1 時可能大小不匹配：/P2";
DYNSizeMismatchInCallOfArray1.Request="參數 1 和 /P1 的大小 /P2 不同。";
DYNSizeMismatchInCallOfArray2.Request="大小分別為 /P1 和 /P2。";
DYNKernelLogError_0176.Request="無法執行：不支持未展開的記錄數組。";
DYNCatArg1Bad.Request="函數 cat 在調用中需要將介于 1 與尺寸數目之間的常量作為第一個參數";
DYNCatArg1Bad.Diagnostic="  /P1";
DYNSizeMismatchInCallOfCat.Request="在調用 /P1 時大小不匹配：/P2";
DYNSizePossibleMismatchInCallOfCat.Request="在調用 /P1 時大小不匹配：/P2";
DYNSizeMismatchInCallOfCat1.Request="參數 2 和 /P1 的大小 /P2 不同。";
DYNSizeMismatchInCallOfCat2.Request="大小分別為 /P1 和 /P2。";
DYNKernelLogError_0177.Request="無法執行：不支持未展開的記錄數組。";
DYNKernelLogError_0178.Request="無法執行：不支持未展開的記錄數組。";
DYNSizeMismatchInCallOfSquareBrackets.Request="調用 [] 時大小不匹配：/P1";
DYNSizePossibleMismatchInCallOfSquareBrackets.Request="調用 [] 時大小不匹配：/P1";
DYNSizeMismatchInCallOfSquareBrackets1.Request="參數 1 和 /P1 的大小 /P2 不同。";
DYNSizeMismatchInCallOfSquareBrackets2.Request="大小分別為 /P1 和 /P2。";
DYNBuiltinNonSimpleVarRef.Request="運算符 /P1 的參數必須是變量參考。";
DYNBuiltinNonSimpleVarRef.Diagnostic=" 此規則不適用于調用：/P2";
DYNSmoothArg1Bad.Request="/P2 中的參數數目 /P1";
DYNSmoothArg1Bad.Diagnostic=" 屬于 /P3 類型，但它必須為連續，且僅包含 /P4。";
DYNCommaListInBadPlace.Request="逗號分隔的表達式列表僅可以用作函數參數";
DYNCommaListInBadPlace.Diagnostic="及用在含多個輸出的函數調用的左側，但在以下位置中找到：\n  /P1";
EmptySlotatBadPlace.Request="函數 emptySlot 只應出現在多個輸出的左側，但找到";
EmptySlotatBadPlace.Diagnostic="  /P1";
DYNReinitBadArg1.Request="reinit 的第一個參數必須為 Real 的子類型，";
DYNReinitBadArg1.Diagnostic="但此類型為 /P1。";
DYNReinitBadArg2.Request="reinit 的第二個參數必須為數值表達式，";
DYNReinitBadArg2.Diagnostic="但此類型為 /P1。";
DYNReinitArgsBadDims.Request="reinit 中的尺寸不兼容。";
DYNReinitArgsBadDims.Diagnostic="第一個參數的維度為 /P1，而第二個參數的維度為 /P2。";
DYNReinitArgsBadA.Request="reinit 的第一個參數必須為連接時間 Real 變量";
DYNReinitArgsBadA.Diagnostic="（且必須對它應用 der），但它不是變量。";
DYNReinitArgsBadB.Request="reinit 的第一個參數必須為連接時間 Real 變量";
DYNReinitArgsBadB.Diagnostic="（且必須對它應用 der），但此變量未聲明？";
DYNReinitArgsBadC.Request="reinit 的第一個參數必須為連接時間 Real 變量";
DYNReinitArgsBadC.Diagnostic="（且必須對它應用 der），但此變量具有可變性 /P1。";
DYNSizeMismatchInCallOfReinit.Request="在調用 reinit 時大小不匹配：/P1";
DYNSizePossibleMismatchInCallOfReinit.Request="在調用 reinit 時可能大小不匹配：/P1";
DYNSizeMismatchInCallOfReinit1.Request="參數的大小 /P1 為 /P2 和 /P3。";
DYNSizeMismatchInCallOfReinit1.Diagnostic="根據需要，兩者不相等。";
DYNReinitArg.Request="/P2 的參數 /P1 與第一個參數的大小不同。";
DYNKernelLogMessage_0301.Request="/P1";
DYNWriteToFileNoOutputs.Request="沒有來自 /P1 的輸出";
DYNValueTooComplexForMatFile.Request="值不夠簡單，以致無法寫入 Mat 文件。";
DYNValueTooComplexForTxtFile.Request="值不夠簡單，以致無法寫入 txt 文件。";
DYNValueFileTypeUnknown.Request="只能將值寫入已知文件類型(*.mos,*.mat,*.txt)，且無法標識  /P1";
DYNKernelLogError_0179.Request="錯誤：無法在 C 代碼中使用 /P1。";
DYNWriteToFileArgNotScalarString.Request="參數 /P1 應為 /P2 中的標量字符串";
DYNKernelLogWarning_0052.Request="builtin 函數 /P1 不支持導數標注。";
DYNKernelLogError_0180.Request="未能打開文件 /P1。";
DYNKernelLogError_0181.Request="未能打開文件 /P1。";
DYNKernelLogError_0182.Request="名稱 /P1 出現多次。";
DYNKernelLogError_0183.Request="未能打開文件 /P1。";
DYNCallWBadVectorization.Request="調用 /P1 時向量化不正確";
DYNCallWBadVectorization1.Request="每個向量化參數必須添加相同數量的額外尺寸。";
DYNCallWBadVectorization2.Request="參數 /P1 已添加 /P2 個尺寸，而參數 /P3 在以下位置中添加了 /P4 個尺寸：";
DYNCallWBadVectorization2.Diagnostic="  /P5";
DYNCardinalityBadArg.Request="函數 /P1 必須具有一個連接器參數";
DYNCardinalityBadArg.Diagnostic="  /P2";
DYNKernelLogError_0184.Request="錯誤：內部錯誤：未展開的 /P1。";
DYNArrayIsNotHet.Request="在數組 /P2 上使用 /P1，但元素的值不相等";
DYNArrayIsNotHet.Diagnostic="/P3 的值為 /P4而，/P5 的值為 /P6。";
DYNDecoupleNonSimpleVarRef.Request="運算符 /P1 的參數必須是變量參考。";
DYNDecoupleNonSimpleVarRef.Diagnostic=" 此規則不適用于調用：/P2";
DYNMustDuration.Request="必須是持續時間。";
DYNMustRational.Request="必須是有理數。";
DYNUnexpectedCallOfPrevious.Request="發現調用 /P1";
DYNUnexpectedCallOfPrevious.Diagnostic="  /P2\n位于意外的位置。";
DYNSynchronousSizeScalarArrayMismatch.Request="如果運算符 /P1 的第一個參數為標量，則其他參數必須為標量。";
DYNSynchronousSizeScalarArrayMismatch.Diagnostic=" 此規則不適用于調用：/P2";
DYNSynchronousNonSimpleVarRef.Request="運算符 /P1 的參數必須是變量參考。";
DYNSynchronousNonSimpleVarRef.Diagnostic=" 此規則不適用于調用：/P2";
DYNSynchronousExpandFailure.Request="未能展開調用的數組參數 /P1：/P2";
DYNSynchronousSizeMisMatch.Request="/P2 的參數 /P1 與第一個參數的大小不同。";
DYNPeriodicSampleArg2BadType.Request="/P1 的第二個參數必須是布爾子類型。";
DYNPeriodicSampleArg2BadType.Diagnostic="但此參數的類型為 /P2。";
DYNUnexpectedCallOfTransition.Request="發現調用 /P1";
DYNUnexpectedCallOfTransition.Diagnostic="  /P2\n位于意外的位置。";
DYNConstrainBadNumberofArgs.Request="使用 /P1 的輸入數目不正確。";
DYNConstrainBadNumberofArgs.Diagnostic="預期至少有一個輸入，但一個也沒有。\n調用：/P2";
DYNUseNotAtEquationLevel.Request="運算符 /P1 的函數調用";
DYNUseNotAtEquationLevel.Diagnostic="但它是在方程式級別使用的特殊運算符。\n調用：/P2";
DYNConstrainBadArgTypes.Request="約束的所有參數必須是 Real 的子類型，";
DYNConstrainBadArgTypes.Diagnostic="但參數 /P1 的類型是 /P2。";
DYNConstrainBadArgDims.Request="約束的參數必須具有相同的維度";
DYNConstrainBadArgDims.Diagnostic="但第一個參數的維度為 /P1\n，而參數 /P2 的維度為  /P2。";
DYNUnexpectedCall.Request="發現調用 /P1";
DYNUnexpectedCall.Diagnostic="  /P2\n位于意外的位置。";
DYNOverdeterminedConnectorsBad.Request="處理超定連接器出錯或失敗。";
DYNDefinePotentialRootWrongNumberOfArgs.Request="使用 /P1 的輸入數目不正確";
DYNDefinePotentialRootWrongNumberOfArgs.Diagnostic="預期有一個或兩個輸入。\n調用：/P2";
DYNDefinePotentialRootArg2BadType.Request="/P1 的第二個參數必須是整數的子類型，";
DYNDefinePotentialRootArg2BadType.Diagnostic="但此參數的類型為 /P2。";
DYNDefinePotentialRootArg2NonScalar.Request="/P1 的第二個參數必須是標量，";
DYNDefinePotentialRootArg2NonScalar.Diagnostic="而其維度為 /P2";
DYNUniqueRootWrongNumberOfArgs.Request="使用 /P1 的輸入數目不正確";
DYNUniqueRootWrongNumberOfArgs.Diagnostic="預期有一個或兩個輸入。\n調用：/P2";
DYNUniqueRootArg2BadType.Request="/P1 的第二個參數必須是字符串的子類型，";
DYNUniqueRootArg2BadType.Diagnostic="但此參數的類型為 /P2。";
DYNUniquelRootArg2NonScalar.Request="/P1 的第二個參數必須是標量，";
DYNUniquelRootArg2NonScalar.Diagnostic="而其維度為 /P2";
DYNUniqueRootIndicesWrongNumberOfArgs.Request="使用 /P1 的輸入數目不正確";
DYNUniqueRootIndicesWrongNumberOfArgs.Diagnostic="預期有兩個或以上的輸入。\n調用：/P2";
DYNUniqueRootIndicesArg3BadType.Request="/P1  的第三個參數必須是字符串的子類型，";
DYNUniqueRootIndicesArg3BadType.Diagnostic="但此參數的類型為 /P2。";
DYNUniquelRootIndicesArg3NonScalar.Request="/P1  的第三個參數必須是標量，";
DYNUniquelRootIndicesArg3NonScalar.Diagnostic="而其維度為 /P2";
DYNUniqueRootIndicesFailure.Request="求值失敗";
DYNUniqueRootIndicesFailure.Diagnostic="/P1。";
DYNStreamInStreamLog.Request="將 /P1 變換為 /P2";
DYNNonSupprtedOperator.Request="此上下文中不支持運算符 /P1。";
DYNStreamActualStreamLog.Request="將 /P1 變換為";
DYNStreamActualStreamLog.Diagnostic="/P2";
DYNKernelLogMessage_0302.Request="";
DYNKernelLogMessage_0303.Request="達到了遞歸限制：";
DYNKernelLogMessage_0303.Diagnostic="  /P1。\n";
DYNKernelLogMessage_0304.Request="函數出錯：/P1。";
DYNKernelLogWarning_0053.Request="警告：函數 /P1 指定了導數 /P2，但";
DYNKernelLogWarning_0053.Diagnostic="",
" /P3 /P4 函數與導數的 /P5 /P6 不匹配。\n";
DYNFunctionUnitBadDer.Request="/P2 /P3 的函數 /P1";
DYNFunctionUnitBadDer.Diagnostic="與 /P4  /P5 中對應導數的單位不一致。";
DYNFunctionUnitBadVar.Request="/P2 /P3 的函數 /P1";
DYNFunctionUnitBadVar.Diagnostic="與 /P4  /P5 中對應變量的單位不一致。";
DYNKernelLogWarning_0054.Request="警告：函數 /P1 已指定導數 /P2，但輸出不匹配。";
DYNKernelLogWarning_0055.Request="警告：函數 /P1 已指定導數 /P2，但輸出不匹配。";
DYNKernelLogWarning_0056.Request="警告：函數 /P1 已指定導數 /P2，但輸入不匹配。";
DYNKernelLogWarning_0057.Request="函數 /P1 和其導數 /P2 發生內部錯誤。";
DYNKernelLogWarning_0058.Request="警告：函數 /P1 已指定導數 /P2，但輸入不匹配。";
DYNKernelLogWarning_0059a.Request="警告：IncludeDirectory 標注必須指定現有目錄。";
DYNKernelLogWarning_0059a.Diagnostic=" 此規則不適用于函數/P1。\n";
DYNKernelLogWarning_0059.Request="警告：Include 標注必須指定字符串文字。";
DYNKernelLogWarning_0059.Diagnostic=" 此規則不適用于函數/P1。\n";
DYNKernelLogWarning_0060.Request="警告：Lib 必須指定此類字符串文字或數組。";
DYNKernelLogWarning_0060.Diagnostic=" 此規則不適用于函數/P1。\n";
DYNKernelLogWarning_0060a.Request="警告：LibraryDirectory 標注必須指定現有目錄。";
DYNKernelLogWarning_0060a.Diagnostic=" 此規則不適用于函數/P1。\n";
DYNKernelLogWarning_0061.Request="警告：函數 /P1 已指定線性(linear=/P2)=... 但 /P3 并非函數的輸入。";
DYNKernelLogWarning_0062.Request="警告：函數 /P1 已指定導數(noDerivative=/P2)=... 但 /P3 并非函數的輸入。";
DYNKernelLogWarning_0063.Request="警告：函數 /P1 已指定導數(noDerivative(/P2=...))=... 但 /P3 并非函數的輸入。";
DYNKernelLogWarning_0064.Request="警告：函數 /P1 已指定導數(zeroDerivative=/P2)=... 但 /P3 并非函數的輸入。";
DYNKernelLogWarning_0065.Request="函數 /P1 已指定導數 /P2，但找不到。";
DYNKernelLogError_0185.Request="錯誤：函數 /P1 將偏導數作為“long 型基類”（即使用 extends and not =），不支持此操作。";
DYNKernelLogError_0186.Request="函數調用非函數 /P1。";
DYNKernelLogError_0187.Request="錯誤：當前版本無法將函數 /P1 的記錄結果轉換";
DYNKernelLogError_0187.Diagnostic="",
"為調用函數 /P2 中不同的記錄參數。\n";
DYNKernelLogError_0188.Request="錯誤：當前版本無法將 if-then-else 記錄表達式轉換";
DYNKernelLogError_0188.Diagnostic="",
"為調用函數 /P1 中不同的記錄參數。\n";
DYNKernelLogError_0189.Request="錯誤：當前版本無法將下標表達式轉換";
DYNKernelLogError_0189.Diagnostic="",
"為調用函數 /P1 中不同的記錄參數。\n";
DYNKernelLogError_0189a.Request="錯誤：當前版本無法將記錄變量轉換";
DYNKernelLogError_0189a.Diagnostic="",
"為調用函數 /P1 中不同的記錄參數 - 確保此函數并非具有硬編碼大小。\n";
DYNKernelLogError_0189b.Request="錯誤：當前版本無法將記錄數組轉換";
DYNKernelLogError_0189b.Diagnostic="",
"為調用函數 /P1 中不同的記錄參數 - 確保此函數并非具有硬編碼大小。\n";
DYNKernelLogError_0190.Request="內部錯誤。";
DYNKernelLogError_0192.Request="內部錯誤：在調用函數 /P2 時記錄中缺少部件 /P1。";
DYNKernelFunctionInputInternal_Recursive.Request="錯誤：在調用 /P1 時，函數內部為函數的函數輸入生成代碼失敗";
DYNKernelLogError_0193.Request="錯誤：初始化元素對象類型 /P1 失敗。";
DYNKernelLogError_0193.Diagnostic="無法直接調用構造函數。\n";
DYNDefEquBad.Request="定義方程式中的表達式無效：/P1 = /P2";
DYNKernelLogWarning_0066.Request="警告：起始值只應出現在模型中，";
DYNKernelLogWarning_0066.Diagnostic="",
"但在函數 /P2 中找到部件 /P1\n",
"的起始值。\n將忽略它。\n";
DYNFuncTempInput.Request="只有函數的頂層參數可以為輸入，但臨時變量 /P1 含有作為其元素輸入 /P2";
DYNFuncTempInput2.Request="只有函數的頂層參數可以為輸出，但臨時變量 /P1 含有作為其元素輸出 /P2";
DYNVariableSubNotInteger.Request="變量 /P2 聲明中的下標 /P1 并非整數。";
DYNNeedVaryingArraySizes.Request="若要在腳本中動態使用可變的數組大小，請與支持人員聯系。";
DYNRecStartNotRec.Request="對于記錄變量 /P1，起始值不是記錄，而 /P2 的起始值為 /P3";
DYNRecStartDimsBad.Request="記錄變量 /P1 具有 /P2 個尺寸，但其起始值具有 /P3 個尺寸，";
DYNRecStartDimsBad.Diagnostic="起始值為：/P4 ";
DYNKernelLogMessage_0306.Request="警告：輸入 /P1 的默認值取決于函數 /P3 中的 /P2";
DYNKernelLogMessage_0306.Diagnostic="",
"包常量在使用時必須求值。\n";
DYNKernelLogMessage_0307.Request="錯誤：輸入 /P1 的默認值取決于函數 /P3 中的變量 /P2";
DYNKernelLogMessage_0307.Diagnostic="",
"系統不支持這種情況。\n";
DYNLogBeingDefaultValue.Request="為 /P1 的默認值";
DYNLogBeingStartValue.Request="為 /P1 的起始值（即綁定指派）";
DYNFuncVarUnitBad.Request="函數 /P1 中變量的單位不正確。";
DYNFuncVarDeclBad.Request="以下變量聲明失敗：";
DYNFuncVarDeclBad.Diagnostic="/P1";
DYNCallingEmptyFunc.Request="調用函數需要算法或外部聲明，";
DYNCallingEmptyFunc.Diagnostic="但找不到函數 /P1 的算法和外部聲明。";
DYNFoundErrorInFunc.Request="函數 /P1 中發現錯誤。";
DYNFunHasExternalAndAlgorithm.Request="函數 /P1 中的外部和算法截面。";
DYNExtFuncReturnBad.Request="在函數 /P1 的外部函數調用中返回變量";
DYNExtFuncReturnBad.Diagnostic="必須是標量值臨時或輸出變量。";
DYNExtFuncReturnBadA.Request="但得到的 \'/P1\' 并非變量。";
DYNExtFuncReturnBadB.Request="但得到的 \'/P1\' 并非函數中聲明的變量。";
DYNExtFuncReturnBadC.Request="但得到的 \'/P1\' 含有下標。";
DYNExtFuncReturnBadD.Request="但得到的 \'/P1\' 屬于輸入變量。";
DYNExtFuncReturnBadE.Request="但得到的 \'/P1\' 并非標量變量。";
DYNExtFuncCallSubscript.Request="在函數 /P1 的外部函數調用中使用下標。";
DYNExtFuncCallSubscript.Diagnostic="非法參數為 /P2";
DYNExtFuncCallSizeFunc.Request="在函數 /P1 的外部函數調用中非法使用大小函數";
DYNExtFuncCallSizeFunc.Diagnostic="非法參數為 /P2\n調用大小函數必須具有兩個參數。\n第一個參數必須是不含下標的變量，而第二個參數必須是常量整數。";
DYNExtFuncCallSizeArgBad.Request="大小參數處于函數 /P1 的外部函數調用的界限之外";
DYNExtFuncCallSizeArgBad.Diagnostic="非法參數為 /P2。\n第二個參數應介于 1 和 /P2 之間。";
DYNExtFuncCallArgBad.Request="在函數 /P1 的外部函數調用中存在非法參數";
DYNExtFuncCallArgBad.Diagnostic="非法參數為 /P2。\n只允許使用常量、部件參考和部件參考的大小。";
DYNFuncAssVarBad.Request="無法確定函數 /P1 中的指派變量";
DYNFuncAssVarBad.Diagnostic="請注意，函數中不支持記錄數組。";
DYNFuncAssToInput.Request="輸入變量的賦值：/P1";
DYNFuncAssToInput.Diagnostic="在函數 /P2 中";
DYNFuncAssToPar.Request="參數或常量的賦值：/P1";
DYNFuncAssToPar.Diagnostic="在函數 /P2 中";
DYNUnitErrorInFunction.Request="在函數 /P1 中";
DYNUnitErrorInFunction.Diagnostic="/P2";
DYNKernelLogError_0194.Request="錯誤：無法計算 /P1 的偏導數。";
DYNInverseFunction.Request=" 在函數 /P1 中";
DYNInverseFunction.Diagnostic="在反函數 /P2 中\n以下輸入/輸出未出現：/P3";
DYNKernelLogError_0195.Request="錯誤：不支持向量化記錄函數。";
DYNKernelLogError_0196.Request="錯誤：不支持向量化未展開的記錄函數。";
DYNKernelLogError_0197.Request="錯誤：未知大小的記錄數組。";
DYNKernelLogError_0198.Request="錯誤：不支持向量化記錄函數。";
DYNKernelLogError_0199.Request="結構存在內部錯誤，請向支持人員報告。";
DYNKernelLogWarning_0067.Request="不支持：在函數 /P1 中使用尺寸“:”聲明變量 /P2。";
DYNKernelLogWarning_0067.Diagnostic=" dsmodel.c 尚不支持此操作，如果在模型中調用，函數將失敗。";
DYNKernelLogError_0200.Request="記錄變量存在內部錯誤。請與支持人員聯系";
DYNExtFuncRecordExpr.Request="Modelica 不允許記錄表達式 to/from 外部函數。請使用記錄變量。";
DYNExtFuncArgRecWArray.Request="無法處理外部函數的參數中的記錄數組。";
DYNExtFuncRecArgAlphabetic.Request="在調用外部函數中使用記錄參數。";
DYNExtFuncRecArgAlphabetic.Diagnostic="記錄的成員會按字母順序排序。";
DYNExtFuncNonCRecord.Request="Modelica 只允許使用 C 中的記錄 to/from 外部函數（但您使用了非 C 函數）。";
DYNExtFuncNonBadArgLog.Request="參數：/P1";
DYNFuncInvalidExpr.Request="函數 /P1 包含無效的表達式。";
DYNTranslationAborted.Request="翻譯中止。";
DYNErrorInFunction.Request="函數 /P1 中出錯。";
DYNFuncCannotSortBindings.Request="無法排序函數 /P1 中的綁定。";
DYNExtFuncRecordReturn.Request="Modelica 不允許外部函數返回結構。";
DYNExtFuncRecordReturn.Diagnostic="返回值：/P1";
DYNKernelLogError_0201.Request="錯誤：函數 /P1 包含非算法。";
DYNKernelLogError_0202.Request="錯誤：函數 /P1 中存在多個算法。";
DYNKernelLogError_0203.Request="錯誤：函數 /P1 同時包含算法和外部子句。";
DYNKernelLogError_0204.Request="錯誤：函數 /P1 中存在初始方程式/算法。";
DYNExtLangInvalid.Request="外部語言無效：函數 /P2 中的 /P1 。";
DYNKernelLogError_0205.Request="錯誤：Dymola 的當前版本無法處理";
DYNKernelLogError_0205.Diagnostic=" 函數 /P1 的矩陣字符串輸入/輸出。\n";
DYNKernelLogMessage_0327.Request="必須轉換函數 /P1。";
DYNFuncMaxRecursionDeepth.Request="已達到函數 /P1 中的最大遞歸深度";
DYNCallingFuncNoBody.Request="調用既非外部，也不含幾何體的函數 /P1。";
DYNKernelLogMessage_0328.Request="未能執行命令 /P1。";
DYNKernelLogError_0206.Request="錯誤：當前版本無法為";
DYNKernelLogError_0206.Diagnostic="",
"未展開的數組拼接導數表達式生成代碼，請參閱 dsmodel.c 獲取詳細信息。\n";
DYNKernelLogError_0207.Request="錯誤：當前版本無法為";
DYNKernelLogError_0207.Diagnostic="",
"未展開的數組拼接表達式生成代碼，請參閱 dsmodel.c 獲取詳細信息。\n";
DYNDelayFuncBadVectorization.Request="調用 /P1 時向量化不正確";
DYNDelayFuncBadVectorization.Diagnostic="調用：/P2";
DYNDelayFuncBadVectorization1.Request="所有非標量參數必須具有相同的尺寸數目，";
DYNDelayFuncBadVectorization1.Diagnostic="但參數 /P1 具有 /P2 個尺寸，\n而參數 /P3 則具有 /P4 個尺寸。";
DYNSizeMismatchInVectorization.Request="在向量化以下名稱的函數 /P1 時大小不匹配：";
DYNSizeMismatchInVectorization.Diagnostic="/P2";
DYNPossibleSizeMismatchInVectorization.Request="在向量化以下名稱的函數 /P1 時可能大小不匹配：";
DYNPossibleSizeMismatchInVectorization.Diagnostic="/P2";
DYNSizeMismatchInVectorization1.Request="參數 /P2 和 /P3 的大小 /P1 分別為 /P4 和 /P5。";
DYNSizeMismatchInVectorization1.Diagnostic="根據需要，兩者不相等。";
DYNKernelLogError_0208.Request="錯誤：當前版本無法為";
DYNKernelLogError_0208.Diagnostic="",
"未展開的數組延遲表達式生成代碼，請參閱 dsmodel.c 獲取詳細信息。\n";
DYNKernelLogWarning_0069.Request="警告：條件代碼中找到延遲運算符 /P1。";
DYNKernelLogWarning_0069.Diagnostic="",
"它只有在活動狀態時才能存儲延遲的結果。\n";
DYNSaveModel_0.Request="找不到選定的模型。";
DYNSaveEncryptedModel_0.Request="找不到選定的模型。";
DYNSaveEncryptedModel_1.Request="選定的模型或包已加密。";
DYNSaveEncryptedModel_2.Request="只有頂層模型或包可以加密。";
DYNSaveEncryptedModel_3.Request="無法打開臨時文件以加密。";
DYNExportHTMLDirectory_0.Request="找不到選定的模型。";
DYNKernelLogMessage_0329.Request="錯誤：無法讀取 /P1 中的 dsin.txt";
DYNKernelLogMessage_0330.Request="錯誤：調用 /P2 時無法讀取變量 /P1";
DYNKernelLogMessage_0331.Request="錯誤：無法在 /P1 中寫入 dsin.txt";
DYNKernelLogMessage_0332.Request="/P1";
DYNKernelLogMessage_0333.Request="/P1";
DYNKernelLogMessage_0334.Request="未找到類 /P1。";
DYNKernelLogMessage_0335.Request="內存統計信息：/P1";
DYNKernelLogMessage_0336.Request="正常：             /P2 塊中的 /P1 字節";
DYNKernelLogMessage_0337.Request="C 運行時：          /P2 塊中的 /P1 字節";
DYNKernelLogMessage_0338.Request="無可用空間：   /P2 塊中的 /P1 字節";
DYNKernelLogMessage_0339.Request="忽略客戶端：      /P2 塊中的 /P1 字節";
DYNKernelLogMessage_0340.Request="空：               /P2 塊中的 /P1 字節";
DYNKernelLogMessage_0341.Request="最大分配：/P1 字節";
DYNKernelLogMessage_0342.Request="總分配：/P1 字節";
DYNKernelLogError_0209.Request="錯誤：嘗試重新定義 /P1 已忽略";
DYNKernelLogMessage_0343.Request="使用來自下面的舊定義：";
DYNKernelLogError_0210.Request="嘗試重新定義 /P1 已忽略";
DYNKernelLogMessage_0344.Request="使用來自下面的舊定義：";
DYNKernelLogError_0211.Request="錯誤：/P1";
DYNKernelLogError_0211.Diagnostic="只應包含包 /P2 的定義\n我們拒絕讀取此類頂層包，因為它可能是因 package.mo 文件放置錯誤所致\n";
DYNKernelLogMessage_0345.Request="忽略包 /P1，因為";
DYNKernelLogMessage_0345.Diagnostic=" /P2\n 丟失。\n";
DYNKernelLogError_0212.Request="錯誤：不正確的包名稱 /P1";
DYNKernelLogMessage_0346.Request="從目錄中讀取包 /P1";
DYNKernelLogMessage_0346.Diagnostic=" /P2\n";
DYNKernelLogMessage_0347.Request="已關閉 /P1";
DYNKernelLogError_0213.Request="錯誤：查找類 /P1 時";
DYNKernelLogError_0213.Diagnostic=" 找到屬于包的 /P2 /P3,\n。\n",
" 請確定 MODELICAPATH 不包含包內的目錄\n ，且當前目錄不在包內。\n";
DYNKernelLogMessage_0348.Request="正在導入“/P1”...";
DYNKernelLogMessage_0349.Request="正在導入“/P1”...";
DYNKernelLogMessage_0350.Request="已關閉“/P1”";
DYNKernelLogError_0214.Request="錯誤：未找到類 /P1";
DYNKernelLogError_0215.Request="錯誤：按需讀取文件 /P1";
DYNKernelLogError_0215.Diagnostic=" 以便找到包 /P2，但未找到。\n";
DYNKernelLogWarning_0070.Request="未實施非標準的警告";
DYNKernelLogWarning_0071.Request="未實施命令 /P1";
DYNKernelLogError_0216.Request="";
DYNKernelLogMessage_0351.Request="部件（非連接器/類型）：/P1（用戶 /P2）";
DYNKernelLogMessage_0351.Diagnostic="類：/P3（用戶 /P4）\n";
DYNKernelLogMessage_0352.Request="搜索";
DYNKernelLogMessage_0352.Diagnostic="",
"層次：        /P1\n",
"本地：                /P2\n",
"內部：                /P3\n",
"查找包：/P4\n",
"需求實例化： /P5\n";
DYNKernelLogMessage_0353.Request="部件元素實例化";
DYNKernelLogMessage_0353.Diagnostic="",
"總數：              /P1\n",
"空環境：   /P2\n",
"空修改：  /P3\n",
"已合并的環境：/P4\n",
"返回此項：         /P5\n",
"結構：             /P6\n",
"內建類型：      /P7\n";
DYNKernelLogMessage_0354.Request="類實例化";
DYNKernelLogMessage_0354.Diagnostic="",
"總數：                /P1\n",
"非實例化：     /P2\n",
"試用：                /P3\n",
"插入此項：          /P4\n";
DYNKernelLogMessage_0355.Request="部件實例數目";
DYNKernelLogMessage_0356.Request="/P1   /P2";
DYNKernelLogMessage_0357.Request="總數：來自 /P3 可用類中 /P2 類的實例化部件 /P1。";
DYNKernelLogMessage_0358.Request=" 但部件 /P1 的流屬性不匹配。";
DYNKernelLogMessage_0358.Diagnostic="  流屬性僅與流屬性匹配，反之亦然。";
DYNKernelLogMessage_0359.Request=" 但嘗試增加部件 /P1 的可變性。";
DYNKernelLogMessage_0360.Request=" 但缺少部件 /P1。";
DYNKernelLogMessage_0361.Request=" 但缺少公共部件 /P1（已聲明受保護）。";
DYNKernelLogMessage_0362.Request="   部件 /P1 內發現錯誤。";
DYNKernelLogMessage_0363.Request=" 但部件 /P1 存在不同的內部/外部限定符。";
DYNKernelLogMessage_0364.Request="   部件 /P1 內發現錯誤。";
DYNKernelLogMessage_0365.Request=" 但存在子類型意外的附加成員 /P1。";
DYNKernelLogMessage_0365.Diagnostic="",
" 由于某些原因，Modelica 中不允許此情況，請將 enumeration(:) 用于未指定的枚舉。";
DYNKernelLogMessage_0366.Request=" 但在枚舉中子類型缺少成員 /P1。";
DYNKernelLogMessage_0367.Request=" 但枚舉器元素 /P1 含有不同的名稱 /P2 和 /P3。";
DYNKernelLogMessage_0368.Request=" 但枚舉和非枚舉相混合。";
DYNKernelLogMessage_0369.Request=" 但缺少公共 /P1 /P2。";
DYNKernelLogMessage_0370.Request="   /P1 /P2 內發現錯誤。";
DYNKernelLogMessage_0371.Request=" 但連接器部件 /P1 默認情況下不可連接。";
DYNKernelLogMessage_0372.Request=" 但新引入的部件 /P1 缺少默認值。";
DYNKernelLogMessage_0373I.Request=" 但 /P1:th 函數輸入是 /P2，但應該是 /P3";
DYNKernelLogMessage_0373O.Request=" 但 /P1:th 函數輸出是 /P2，而應該是 /P3";
DYNKernelLogMessage_0374.Request=" 但 /P1 是內建類型，而不是 /P2。";
DYNKernelLogMessage_0375.Request=" 但/P1 不是內建類型，而 /P2 則是內建類型。";
DYNKernelLogMessage_0376.Request=" 但專用類 /P1 /P2 和 /P3 /P4 不同。";
DYNKernelLogMessage_0377.Request=" 但內建類型 /P1 和 /P2 不同。";
DYNKernelLogWarning_0072.Request="警告：層次重新聲明修飾符 /P1";
DYNKernelLogError_0217.Request="屬性修飾符“/P1”不是表達式，而：",
"";
DYNKernelLogError_0217.Diagnostic="  “/P2”則是。";
DYNKernelLogError_0218.Request="屬性修飾符“/P1”不是表達式，而：",
"";
DYNKernelLogError_0218.Diagnostic="  “/P2”則是。";
DYNKernelLogError_0219.Request="/P1 的多個修飾符。";
DYNKernelLogWarning_0073.Request="警告：不支持：修飾符 /P1 含有下標。";
DYNKernelLogError_0220.Request="不支持：修飾符 /P1 含有下標。";
DYNKernelLogWarning_0074.Request="覆蓋 /P1 的最終修飾符。";
DYNKernelLogWarning_0075.Request="記錄含有值，并嘗試修改特定元素。";
DYNKernelLogWarning_0076.Request="/P1 等元素修改將被忽略。";
DYNKernelLogMessage_0378.Request="在以下位置找到嘗試的覆蓋：";
DYNKernelLogError_0221.Request="覆蓋 /P1 的最終修飾符";
DYNKernelLogMessage_0379.Request="/P1 -> /P2。";
DYNKernelLogMessage_0380.Request="在以下位置找到覆蓋：";
DYNKernelLogMessage_0381.Request="在以下位置通過設置整個記錄覆蓋：";
DYNKernelLogMessage_0382.Request="/P1 的復雜合并。";
DYNKernelLogError_0222a.Request="在 /P2/P3 的約束類中找不到類或部件“/P1”";
DYNKernelLogError_0222.Request="在 /P2 /P3 中找不到類或部件“/P1”";
DYNKernelLogMessage_0383.Request="  在 /P1 中嘗試悠。";
DYNKernelMessage_0222b.Request="/P1 中缺少定義。";
DYNKernelLogError_0223.Request="錯誤：語法“/P1 extends /P2”僅用于重新聲明。";
DYNKernelLogError_0224.Request="缺少基類 /P1";
DYNKernelLogWarning_0078a.Request="運算符可能無法繼承。";
DYNKernelLogWarning_0078a.Diagnostic="",
"但 /P1 繼承自 /P2 /P3。";
DYNKernelLogWarning_0077.Request="/P1 只可能從同類的專用類中繼承，";
DYNKernelLogWarning_0077.Diagnostic="",
"但 /P2 繼承自 /P3 /P4。\n";
DYNKernelLogWarning_0078.Request="連接器只可能從連接器、類型或記錄中繼承，";
DYNKernelLogWarning_0078.Diagnostic="",
"但 /P1 繼承自 /P2 /P3。";
DYNKernelLogWarning_0079.Request="模型只可能從模型、塊或記錄繼承，";
DYNKernelLogWarning_0079.Diagnostic="",
"但 /P1 繼承自 /P2 /P3。";
DYNKernelLogWarning_0080.Request="塊只可能從塊或記錄中繼承，";
DYNKernelLogWarning_0080.Diagnostic="",
"但 /P1 繼承自 /P2 /P3。\n";
DYNKernelLogMessage_0385.Request="Dymola 中出現內部問題。";
DYNKernelLogMessage_0385.Diagnostic=" 該程序將嘗試解決，但請向支持人員報告。\n";
DYNKernelLogWarning_0081.Request="基類 /P1 可替換";
DYNKernelLogWarning_0082.Request="基類 /P1 是可替換包的一部分";
DYNKernelLogWarning_0083.Request="基類 /P1 并非可傳遞性不可替換，";
DYNKernelLogWarning_0083.Diagnostic="",
" 因為它是等于可替換類的短類。";
DYNKernelLogMessage_0386.Request="轉換中斷，因為版本不一致，庫 /P1 使用了舊版 /P2。";
DYNKernelLogMessage_0387.Request="轉換中斷，因為版本不一致。";
DYNReqAbortOfTransl.Request="用戶請求中止轉換。";
DYNKernelLogError_0225.Request="實例化類 /P1 達到了遞歸限制。";
DYNKernelLogMessage_0389.Request="可能因相互依存類造成。";
DYNKernelLogMessage_0390.Request="  部件上下文：/P1";
DYNKernelLogMessage_0390.Diagnostic="",
"  部件聲明為 /P2 /P3";
DYNKernelLogMessage_0391.Request="  上下文：/P1";
DYNKernelLogMessage_0392.Request="類型 /P1 記錄變量的值";
DYNKernelLogError_0226.Request="在添加擴展后，基類 /P1 的查找已更改。";
DYNKernelLogError_0227.Request="嘗試重新聲明 /P1 /P2，但缺少原始聲明。";
DYNKernelLogError_0228.Request="在原始聲明不可替換時，嘗試重新聲明 /P1 /P2。";
DYNKernelLogWarning_0084.Request="本地部件名稱隱藏擴展 /P1。";
DYNKernelLogMessage_0393.Request="注意：擴展本地類型 /P1。";
DYNKernelLogWarning_0085.Request="基類是依賴項，這不是合法的";
DYNKernelLogWarning_0085.Diagnostic="",
"通過擴展子句 /P2 可找到擴展 /P1。";
DYNKernelLogError_0229.Request="/P1 /P2 兩次嘗試從帶有前綴的基本類型/數組類/類擴展。";
DYNKernelLogError_0230.Request="類型 /P1 并非從基本類型擴展。";
DYNKernelLogError_0231.Request="/P1 /P2 并非僅從帶有前綴的基本類型/數組類/類擴展。";
DYNKernelLogError_0231.Diagnostic="",
"  但還包含部件 /P3。\n";
DYNKernelLogError_0232.Request="/P1 /P2 包含方程式。這是非法的";
DYNKernelLogMessage_0394.Request=" 但 /P1 既是部件，也是類。";
DYNKernelLogWarning_0086.Request="公共部件 /P1/P2";
DYNKernelLogWarning_0086.Diagnostic="  在 /P3 /P4 中既非輸入，也非輸出。";
DYNKernelLogError_0233.Request="錯誤：部件 /P1/P2 = /P3/P4，";
DYNKernelLogError_0233.Diagnostic="  但之前 /P5/P6 = /P7/P8。\n 部件并非完全相同。 \n";
DYNKernelLogWarning_0087.Request="警告：部件 /P1/P2 = /P3/P4，";
DYNKernelLogWarning_0087.Diagnostic="  但之前 /P5/P6 = /P7/P8。\n 部件并非完全相同。 \n";
DYNInstLogMessageOverride.Request="  如果您要在基類中覆蓋參數的值";
DYNInstLogMessageOverride.Diagnostic="",
"您無法使用：\n",
"   參數 /P1 /P2/P3;\n",
"    擴展 /P4(/P5/P6=/P7/P8);\n";
DYNInstLogMessageEither1.Request="  請使用以下";
DYNInstLogMessageEither1.Diagnostic="",
"    擴展 /P1;\n",
"  或以下項：\n",
"    參數 /P2 /P3;\n",
"    擴展 /P4;\n\n";
DYNInstLogMessageEither2.Request="  請使用以下";
DYNInstLogMessageEither2.Diagnostic="",
"    擴展 /P1(/P2/P3=/P4/P5);\n\n";
DYNKernelLogMessage_0395.Request="  部件 /P1 通過擴展 /P2 繼承";
DYNKernelLogMessage_0396.Request="  對于在以下位置找到的元素 /P1：";
DYNKernelLogError_0234X.Request="隱藏擴展的類需要子類型";
DYNKernelLogError_0234.Request="  對于通過擴展 /P2 引入的元素 /P1";
DYNKernelLogError_0235.Request="  對于在以下位置找到的元素 /P1：";
DYNKernelLogError_0236.Request=" 與最終部件 /P2 沖突的擴展 /P1";
DYNKernelLogError_0237.Request="  最終部件 /P1。";
DYNKernelLogError_0238.Request="  與 /P2 的保護沖突的擴展 /P1";
DYNKernelLogError_0239.Request=" 部件 /P1 的保護。";
DYNKernelLogError_0240.Request=" 元素 /P1 既是類，也是部件。";
DYNKernelLogMessage_0397.Request="  通過擴展/P1 繼承";
DYNKernelLogMessage_0398.Request="  元素 /P1";
DYNKernelLogWarning_0088.Request=" /P1 /P2 既是長類定義，也是";
DYNKernelLogWarning_0088.Diagnostic="  短類定義。\n",
"  這可能是因將 \n",
"   /P1 /P2\n    ...\n   end /P2;\n   extends /P3（重新聲明 /P1 /P2=/P2);\n",
"  請將此項更改為：\n",
"   /P1 My/P2\n    ...\n   end My/P2;\n   extends /P3（重新聲明 /P1 /P2=My/P2);\n",
"（將 My 替換為適當的前綴）。\n",
" 您可以關閉此警告，方法是設置 /P4:=false;";
DYNKernelLogMessage_0399.Request="  無法寫入此類其他警告。";
DYNKernelLogMessage_0399.Diagnostic="",
"   您可以確保寫入所有項，方法是設置 /P1:=true;";
DYNKernelLogError_0241.Request="在原始聲明不可替換時，嘗試重新聲明 /P1 /P2。";
DYNKernelLogWarning_0089.Request=" /P1 /P2 具有多個似乎并非完全相等的定義。";
DYNKernelLogWarning_0089.Diagnostic="",
"  這不是正確的 Modelica。\n",
"  請確保它們具有不同的名稱或相等。\n",
"  您可以關閉此警告，方法是設置/P3:=false;";
DYNKernelLogMessage_0400.Request="  與以下位置中的元素沖突";
DYNKernelLogError_0242X.Request="重新聲明需要子類型";
DYNKernelLogError_0242.Request="  在 /P1 重新聲明中。";
DYNKernelLogError_0243.Request="在原始聲明不可替換時，嘗試重新聲明 /P1 /P2。";
DYNKernelLogWarning_0090.Request="   未能找到類 /P1 ";
DYNKernelLogWarning_0091.Request="   子類型檢查發生了內部錯誤。";
DYNKernelLogWarning_0092.Request="  在 /P2 的 /P1 中。";
DYNKernelLogError_0244.Request="實例化可能已進入部件 /P1 的循環。";
DYNKernelLogError_0245.Request="無法找到部件 /P2 的基類 /P1。";
DYNKernelLogError_0246.Request="在 /P1 的重新聲明中存在不匹配。";
DYNKernelLogError_0247.Request="無法修改最終類 /P1。";
DYNKernelLogWarning_0093.Request="受保護類 /P1 的修飾符。這是非法的 Modelica。";
DYNKernelLogWarning_0094.Request="最終類 /P1 的修飾符。這是非法的 Modelica。";
DYNKernelLogMessage_0401.Request="/P1 的重新聲明需要原始聲明可替換。";
DYNKernelLogWarning_0095X.Request="重新聲明需要子類型。";
DYNKernelLogWarning_0095.Request="  在 /P1 的重新聲明中。";
DYNKernelLogWarning_0095Y.Request="新類型應為新約束子句的子類型。";
DYNKernelLogWarning_0095Z.Request="類型應為約束子句的子類型。";
DYNKernelLogWarning_0096.Request="  在 /P1 中的聲明中。";
DYNKernelLogError_0248.Request="錯誤：部件聲明為 /P1，但類型指定了 /P2。";
DYNKernelLogError_0249.Request="錯誤：部件聲明為 /P1，但類型指定了 /P2。";
DYNKernelLogMessage_0402.Request="注意：檢查發現該類必須在使用之前修改。";
DYNKernelLogMessage_0403.Request="  若要查閱所有此類問題，請設置 /P1 = true";
DYNKernelLogMessage_0404.Request="  第一個問題是";
DYNKernelLogWarning_0097.Request="記錄或連接器的成員必須在聲明中設置，已修改 /P1。";
DYNKernelLogWarning_0098.Request="僅能設置具有默認值的輸入、參數和變量，但已修改的 /P1。";
DYNKernelLogMessage_0405.Request="/P1 的變量聲明";
DYNKernelLogMessage_0407.Request="  部件上下文：/P1";
DYNKernelLogMessage_0407.Diagnostic="  部件在 /P4 中聲明為 /P2 /P3";
DYNKernelLogMessage_0406.Request="  部件上下文：/P1";
DYNKernelLogMessage_0406.Diagnostic="  部件聲明為 /P2 /P3";
DYNKernelLogMessage_0408.Request="  上下文：/P1";
DYNKernelLogError_0250.Request="未找到部件類型限定符  /P1";
DYNKernelLogError_0251.Request="部件類型限定符 /P1 并非類型";
DYNKernelLogError_0252.Request="部件類型限定符  /P1 是一個包";
DYNKernelLogError_0252A.Request="部件類型限定符 /P1 是一個函數";
DYNKernelLogError_0253.Request="部件類型限定符 /P1 是分部類型。";
DYNKernelLogError_0254.Request="部件類型限定符 /P1 是分部類型";
DYNKernelLogError_0254.Diagnostic="",
"  您可以關閉此檢查，方法是設置 /P2:=false;";
DYNKernelLogMessage_0410.Request="部件類型限定符 /P1 是分部類型";
DYNKernelLogMessage_0410.Diagnostic="",
"  它必須在使用前重新聲明。";
DYNKernelLogWarning_0099.Request="部件類型限定符 /P1 已指定過時的類型：/P2。";
DYNKernelLogMessage_0411.Request="部件類型限定符 /P1 等于分部類型";
DYNKernelLogMessage_0411.Diagnostic="",
"  它必須在使用前重新聲明。";
DYNKernelLogError_0255.Request="帶有非空限定符的外部部件。";
DYNKernelLogError_0256.Request="重新聲明內建類型 /P2 的部件 /P1。";
DYNKernelLogWarning_0100.Request="受保護部件 /P1 的修飾符。這是非法的 Modelica。";
DYNKernelLogWarning_0101.Request="最終部件 /P1 的修飾符。這是非法的 Modelica。";
DYNKernelLogWarning_0102.Request="含有值的常量 /P1 的修飾符。這是非法的 Modelica。";
DYNKernelLogWarning_0103.Request="必須在聲明中設置記錄成員，已修改的 /P1。";
DYNKernelLogWarning_0104.Request="僅能設置具有默認值的輸入、參數和變量，但已修改的 /P1。";
DYNKernelLogWarning_0105.Request="函數部件 /P1 的起始值";
DYNKernelLogWarning_0106A.Request="可替換函數必須是約束類的子類型。";
DYNKernelLogWarning_0106.Request="  在部件 /P1 的聲明中";
DYNKernelLogError_0257.Request="將部件 /P1 重新聲明為 /P2。";
DYNKernelLogError_0258.Request="將部件 /P1 重新聲明為非部件。";
DYNKernelLogMessage_0412.Request="這不合法 - 部件僅可以重新聲明為部件。";
DYNKernelLogMessage_0413.Request="注意：保留 /P2 重新聲明中的 /P1 可變性";
DYNKernelLogMessage_0414.Request="注意：保留 /P2 重新聲明中的 /P1 因果關系";
DYNKernelLogMessage_0415.Request="注意：保留 /P1[/P2] 重新聲明中的數組尺寸";
DYNKernelLogMessage_0416.Request="/P1 的重新聲明將尺寸數目由 /P2 更改為 /P3。";
DYNKernelLogMessage_0417.Request="  新的重新聲明為：/P1[/P2]";
DYNKernelLogWarning_0107A.Request="重新聲明需要子類型。";
DYNKernelLogWarning_0107B.Request="重新聲明不可替換的類型需要類型等效";
DYNKernelLogWarning_0107.Request="  在部件 /P1 的重新聲明中";
DYNKernelLogMessage_0418.Request="/P1 的原始聲明";
DYNKernelLogMessage_0419.Request="自動內部 /P1 不一致。";
DYNKernelLogMessage_0420.Request="/P2 中的內部和外部 /P1 不匹配。";
DYNKernelLogError_0259A.Request="內部必須是外部的子類型";
DYNKernelLogError_0259.Request="  部件外部 /P1 /P2";
DYNKernelLogMessage_0421.Request="  與內部 /P1 /P2 比較";
DYNKernelLogMessage_0422.Request="  發現部件外的外部元素 /P1。";
DYNKernelLogMessage_0422.Diagnostic="",
"  在使用此部件時，您必須添加內部元素。";
DYNKernelLogError_0260.Request="發現部件外的外部元素 /P1。";
DYNKernelLogMessage_0423.Request="警告：在 /P2 中查找內部類時，找到非內部類 /P1";
DYNKernelLogMessage_0424.Request="此類具有頂層外部 /P1，您只能使用此類作為子部件。";
DYNKernelLogMessage_0424.Diagnostic="如果沒有匹配的內部\n/P2，系統將提供以下消息\n";
DYNKernelLogMessage_0425.Request="此類具有頂層外部 /P1，您只能使用此類作為子部件。";
DYNKernelLogMessage_0425.Diagnostic="",
" 在使用此部件時，您必須添加內部元素";
DYNKernelLogMessage_0426.Request="注意：/P1";
DYNKernelLogMessage_0427.Request="錯誤：此類具有頂層外部 /P1，您只能使用此類作為子部件。";
DYNKernelLogMessage_0427.Diagnostic="如果沒有匹配的內部\n/P2，系統將提供以下消息\n";
DYNKernelLogMessage_0428.Request="錯誤：無法使用：/P1";
DYNKernelLogMessage_0429.Request="  未能在 /P2 中找到匹配的內部 /P1。";
DYNKernelLogMessage_0429.Diagnostic="",
"  在使用此部件時，您必須添加內部元素。";
DYNKernelLogMessage_0430.Request="未能在 /P2 中找到匹配的內部 /P1。";
DYNKernelLogWarning_ProtPack.Request="警告：/P1 /P2 已保護 /P3 /P4，";
DYNKernelLogWarning_ProtPack.Diagnostic="",
"不應從外部訪問\n";
DYNKernelLogError_0261.Request="/P1 /P2 不是包，因為它包含 ";
DYNKernelLogError_0261.Diagnostic="",
"  非常量部件 /P3。在非包中查找限于\n",
"封裝的元素。";
DYNKernelLogError_0262.Request="/P1 /P2 不是包，因為它包含";
DYNKernelLogError_0262.Diagnostic="",
"  非常量部件 /P3。在非包中查找限于\n",
" 封裝的元素，但搜索找到 /P4 /P5。\n",
"  您可以關閉此檢查，方法是設置 /P6:=false;";
DYNKernelLogWarning_0108.Request="包 /P1 不符合包的要求，";
DYNKernelLogWarning_0108.Diagnostic="",
"因為它包含非常量 /P2。\n",
"  您可以關閉此警告，方法是設置 /P3:=false;";
DYNKernelLogMessage_0431E.Request="  Modelica 文本：行 /P1";
DYNKernelLogMessage_0431N.Request="  Modelica 文本：鄰近行 /P1";
DYNKernelLogMessage_0432E.Request="  文件：/P1，行 /P2";
DYNKernelLogMessage_0432N.Request="  鄰近文件：/P1，行 /P2";
DYNKernelLogMessage_0433.Request="  在 Modelica 文本中";
DYNKernelLogMessage_0434.Request="  在文件中：/P1";
DYNLocation1B.Request="類 /P1， ";
DYNLocation1A.Request="類 /P1，";
DYNLocation2A.Request="/P1 位于行 /P2";
DYNLocation2B.Request="/P1 鄰近行 /P2";
DYNLocation2C.Request="/P1";
DYNLocation3.Request="，并用于部件 /P1 中";
DYNLocation4.Request="。";
DYNLocationFoundIn.Request="查找范圍 ";
DYNKernelLogError_0263.Request="記錄變量存在內部錯誤";
DYNKernelLogError_0264.Request="無法用于 /P1 (/P2)";
DYNKernelLogError_02971.Request="系統內存或資源不足";
DYNKernelLogMessage_0435.Request="矩陣 /P1 的大小不匹配，預期 /P2x/P3 矩陣，但找到 /P4x/P5";
DYNKernelLogMessage_0436.Request="/P1";
DYNKernelLogMessage_0437.Request="/P1";
DYNKernelLogError_0265.Request="/P1 /P2";
DYNKernelLogMessage_0438.Request="，";
DYNKernelLogMessage_0438.Diagnostic=" /P1";
DYNKernelLogMessage_0439.Request="/P1";
DYNKernelLogMessage_0440.Request="警告：未在結果中找到所有變量。從不完整的結果文件中重新開始可能會導致不可預知的結果。";
DYNKernelLogMessage_0441.Request="/P1/P2";
DYNKernelLogMessage_0442.Request="錯誤：找到 1 個錯誤";
DYNKernelLogMessage_0443.Request="錯誤：找到 /P1  個錯誤";
DYNKernelLogMessage_0444.Request="警告：已發出 1 個警告";
DYNKernelLogMessage_0445.Request="警告：已發出 /P1 個警告";
DYNKernelLogMessage_0446.Request="注意：在包內找到文件 /P1";
DYNKernelLogMessage_0446.Diagnostic=" 。\n 正在從目錄 /P2 中打開整個包\n";
DYNKernelLogError_0266.Request="錯誤：找不到文件 /P1";
DYNKernelLogError_0268NonFile.Request="錯誤：不支持加密數據";
DYNKernelLogError_0268NonFile.Diagnostic="。數據可能已使用 Dymola 內核的最新版本加密。\n";
DYNKernelLogError_0269WrongClass.Request="錯誤：加密的數據用于不同的類。";
DYNKernelLogError_0269NonFile.Request="讀取加密的數據時出錯。";
DYNKernelLogError_0267.Request="錯誤：無法打開文件 /P1";
DYNKernelLogError_0268.Request="錯誤：不支持加密文件 /P1";
DYNKernelLogError_0268.Diagnostic="。文件可能已使用 Dymola 的最新版本加密。\n";
DYNKernelLogError_0269.Request="讀取加密的文件時出錯。";
DYNKernelLogWarning_0109.Request="文件 /P1 不含 within 子句，但應含有“within /P2;”。";
DYNKernelLogWarning_0110.Request="文件 /P1包含“within /P2;”，但應含有“within /P3;”。";
DYNKernelLogMessage_0448.Request="錯誤：嘗試移除備份文件 /P1，由于沒有更改而失敗。";
DYNKernelLogMessage_0448.Diagnostic=" 因為：/P2。\n";
DYNKernelLogMessage_0450.Request="錯誤：寫入文件 /P1 時出現問題";
DYNKernelLogMessage_0450.Diagnostic=" 因為：/P2。\n";
DYNKernelLogMessage_0451.Request="可以在 /P1 中找到備份。";
DYNKernelLogWarning_0111.Request="警告：無法將";
DYNKernelLogWarning_0111.Diagnostic=" 分層包 /P1\n 的目錄由 /P2\n 重命名為 /P3。\n";
DYNKernelLogWarning_0112.Request="警告：將 /P1 不正確的文件名";
DYNKernelLogWarning_0112.Diagnostic=" 由 /P2\n 更改為 /P3。\n";
DYNKernelLogWarning_0113.Request="警告：將舊文件 /P1 重命名";
DYNKernelLogWarning_0113.Diagnostic="  為 /P2：\n";
DYNKernelLogWarning_0114a.Request="警告：無法將舊文件 /P1 重命名";
DYNKernelLogWarning_0114a.Diagnostic="  為 /P2；將移除它。\n";
DYNKernelLogError_0114a.Request="錯誤：無法將舊文件 /P1";
DYNKernelLogError_0114a.Diagnostic="  為 /P2；而且也無法移除它。\n";
DYNKernelLogWarning_0114.Request="警告：無法將舊文件 /P1 重命名";
DYNKernelLogWarning_0114.Diagnostic="  為 /P2。\n";
DYNKernelLogWarning_0115.Request="警告：擦除舊文件失敗：/P1";
DYNKernelLogError_0270.Request="保存 /P1 時出現內部錯誤。";
DYNKernelLogMessage_0452.Request="/P1";
DYNKernelLogMessage_0454.Request=" 部件上下文：/P1";
DYNKernelLogMessage_0454.Diagnostic="  部件在 /P4 中聲明為 /P2 /P3";
DYNKernelLogMessage_0453.Request=" 部件上下文：/P1";
DYNKernelLogMessage_0453.Diagnostic="  部件聲明為 /P2 /P3";
DYNKernelLogMessage_0455.Request="  上下文：/P1";
DYNKernelLogError_0271.Request="在函數 /P1 中找到外部聲明";
DYNKernelFunctionLog_1.Request="不支持帶有默認參數的函數輸入";
DYNKernelLogMessage_0458.Request="在實例化時發生上述問題：/P1";
DYNKernelLogMessage_0459.Request="在 /P2 的 /P1 屬性中。";
DYNKernelLogWarning_0116.Request="警告：內部錯誤。";
DYNKernelLogWarning_0117.Request="警告：內部錯誤。";
DYNKernelLogWarning_0118.Request="警告：內部錯誤。";
DYNKernelLogWarning_0119.Request="警告：內部錯誤。";
DYNKernelLogWarning_0120.Request="警告：內部錯誤。";
DYNKernelLogWarning_0121.Request="警告：內部錯誤。";
DYNKernelLogWarning_0122.Request="警告：內部錯誤。";
DYNKernelLogMessage_0460.Request="在 /P2 的 /P1 屬性中。";
DYNKernelLogMessage_0461.Request="忽略 /P1 屬性。";
DYNKernelLogMessage_0462.Request="Modelica 轉換器的當前版本只能處理";
DYNKernelLogMessage_0462A.Request="具有固定大小的部件數組。";
DYNKernelLogMessage_0462D.Request="具有固定大小的部件數組和具有固定條件的條件部件。";
DYNKernelLogMessage_0462B.Request="具有固定條件的條件部件。";
DYNKernelLogWarning_0123A.Request="但部件 /P1 具有非固定條件 if /P2。";
DYNKernelLogWarning_0123B.Request="但部件 /P1 具有非固定數組尺寸 [/P2]。";
DYNKernelLogMessage_0463A.Request="大小表達式中使用的所有變量必須聲明為常量或參數。";
DYNKernelLogMessage_0463D.Request="大小表達式和條件聲明的條件中使用的所有變量必須聲明為常量或參數。";
DYNKernelLogMessage_0463B.Request="條件聲明的條件中使用的所有變量必須聲明為常量或參數。";
DYNKernelLogError_0273.Request="無法對條件表達式的條件求值。";
DYNKernelLogError_0273.Diagnostic="",
"部件 /P1 含有條件 [/P2]。";
DYNKernelLogMessage_0464.Request="對預先使用函數求值失敗， ";
DYNKernelLogMessage_0464.Diagnostic="意味著我們無法使用類 /P2 的部件 /P1。\n";
DYNKernelLogError_0274.Request="無法使用類 /P2 的部件 /P1，";
DYNKernelLogError_0274.Diagnostic="",
" 因為我們無法預告使用函數 (/P3) 求值，\n",
"指示以上錯誤，且應先更正錯誤。";
DYNKernelLogError_0275.Request="Dymola 的當前版本只能處理具有固定大小的部件數組。";
DYNKernelLogError_0275.Diagnostic="",
"但部件 /P1 具有非固定數組尺寸 [/P2]。";
DYNKernelLogMessage_0466.Request="在變量 /P1 的數組尺寸中。";
DYNKernelLogError_0276.Request="錯誤：找不到文件 /P1";
DYNKernelLogWarning_0124.Request="警告：校驗和與 /P1 不匹配，應為 /P2。";
DYNKernelLogWarning_0125.Request="警告：校驗和與 /P1 不匹配。";
DYNKernelLogMessage_0571.Request="注意：要使用示例進行實驗，請先通過";
DYNKernelLogMessage_0571.Diagnostic="",
"“另存”或“復制”制作本地副本，\n",
"然后再使用本地副本。\n\n",
"如果已經開始實驗，則\n",
"需要執行這些步驟： \n",
"1.“另存”您已修改的內容，\n",
"2. “全部清除”（或重新開始），\n",
"3. 重新加載修改的示例。\n\n",
"對于“另存”和“復制”，您必須將其插入\n",
"到包 <<None>> 并將其保存在\n",
"原始包外面的本地目錄中。\n";
DYNKernelLogWarning_0126.Request="元素運算符 /P1 不是 Modelica 的一部分";
DYNKernelLogMessage_0000.Request="/P1";
DYNKernelLogWarning_0127.Request="結尾名稱 /P1 與類名稱 /P2 不匹配";
DYNKernelLogWarning_0128.Request="/P1 內部存在舊的文本語法錯誤。";
DYNKernelLogWarning_0128.Diagnostic="請顯示文本層，并更正錯誤。 使用“突出顯示語法”以查找語法錯誤。";
DYNKernelLogWarning_0129.Request="接受非法類名稱：/P1（它是關鍵字）。";
DYNKernelLogError_0277.Request="枚舉 /P1 包含重復的成員 /P2";
DYNKernelLogWarning_0130.Request="結尾名稱 /P1 與類名稱 /P2 不匹配";
DYNKernelLogWarning_0131.Request="/P1 內部存在舊的文本語法錯誤。";
DYNKernelLogWarning_0131.Diagnostic="請顯示文本層，并更正錯誤。 使用“突出顯示語法”以查找語法錯誤。";
DYNKernelLogError_0278.Request="函數的導數無法與數組索引組合。";
DYNKernelLogError_0279.Request="函數的導數必須指定函數。";
DYNKernelLogError_0280.Request="擴展子句中缺少基類名稱。";
DYNKernelLogError_0282.Request="當聲明函數的偏導數時無法使用重新聲明。";
DYNKernelLogError_0283.Request="當聲明函數的偏導數時無法使用描述備注。";
DYNModifierAnnotation.Request="Modelica 中不允許使用帶有標注的修飾符。";
DYNKernelLogWarning_0132.Request="接受非法部件名稱：/P1（它是關鍵字）。";
DYNKernelLogError_0284.Request="條件表達式不得出現在重新聲明中";
DYNKernelLogError_0285.Request="忽略非離散屬性 - 不再支持";
DYNKernelLogError_0286.Request="運算符 /P1 只能出現在算法中。";
DYNKernelLogError_0287.Request="在模型中找到單個表達式“/P1”。 ";
DYNKernelLogError_0287.Diagnostic="",
"只允許方程式、指派和程序調用。";
DYNKernelLogError_0288.Request="逗號分隔的表達式列表僅可以";
DYNKernelLogError_0288.Diagnostic="",
"用在函數調用的左側，\n",
"但是發現“/P1 = /P2”。";
DYNKernelLogError_0289.Request="只有部件參考可以出現在指派的左側。",
"但發現“/P1”。";
DYNKernelLogError_0290.Request="錯誤：在 /P1 部分中發現導入語句";
DYNKernelLogError_0291.Request="While 語句不能出現在方程式部分。";
DYNKernelLogError_0292.Request="找到逗號分隔的表達式列表“/P1”，";
DYNKernelLogError_0292.Diagnostic="",
"但它只允許用在方程式/指派的左側，\n",
"及用在函數調用的右側。";
DYNKernelLogError_0293.Request="對逗號分隔的表達式列表“/P1”編制索引";
DYNKernelLogMessage_0470.Request="編譯函數 /P1 /P2。";
DYNKernelLogMessage_0471.Request="用戶請求我們禁止檢查 /P1。";
DYNKernelLogMessage_0473.Request="未檢查交互式函數 /P1。";
DYNHiearchical1.Request="正在檢查分部 /P1 /P2";
DYNHiearchical2.Request="正在檢查 /P1 /P2";
DYNKernelLogMessage_0475.Request="";
DYNKernelLogMessage_0476.Request="約束檢查僅適用于 Modelica 3。";
DYNKernelLogMessage_0477.Request="約束檢查僅適用于不具有修飾符的類。";
DYNKernelLogMessage_0478.Request="/P1 ";
DYNKernelLogMessage_0479.Request="？";
DYNKernelLogMessage_0480.Request="";
DYNKernelLogError_0295.Request="錯誤：無法檢查加密的模型。";
DYNKernelLogError_0296.Request=" /P1 /P2 為分部。";
DYNKernelLogWarning_0133.Request="警告：模型 /P1 中的命令，";
DYNKernelLogWarning_0133.Diagnostic=" 但找不到存儲它的目錄。\n";
DYNKernelLogWarning_0134.Request="警告：模型“/P2”中的命令“/P1”，";
DYNKernelLogWarning_0134.Diagnostic=" 指定的文件 /P3 找不到。\n";
DYNKernelLogMessage_0482.Request="已檢查本地類，正在檢查 /P1";
DYNKernelLogMessage_0484.Request="找不到模型 /P1";
DYNCompilationFordSPACE.Request="--------------";
DYNCompilationFordSPACE.Diagnostic="正在為 dSPACE 目標 /P1 構建模型\n";
DYNDymosimCompilationFailed.Request="編譯 dymosim 失敗。可能因外部 dSPACE RTI 依賴項所致。";
DYNKernelLogWarning_0135.Request="警告：無法解譯實驗標注：/P1 = /P2";
DYNKernelLogError_0297.Request="無法創建 dsin (/P1)";
DYNKernelLogError_02971.Request="系統內存或資源不足";
DYNKernelLogError_0298.Request="錯誤：檢查/轉換回調過程中無法更改模型。";
DYNKernelLogWarning_0136.Request="警告：當前版本無法模擬函數。";
DYNKernelLogError_0299.Request="錯誤：無法轉換帶有修飾符的函數。";
DYNKernelLogMessage_0485.Request="錯誤：編譯 /P1 失敗。請參閱“模擬”選項卡以了解更多信息。";
DYNKernelLogMessage_0486.Request="錯誤：編譯失敗。請參閱“模擬”選項卡以了解更多信息。";
DYNKernelLogMessage_0488.Request="注意：存在可能說明此問題的轉換 /P1。";
DYNKernelLogError_0300.Request="錯誤：模擬失敗";
DYNKernelLogMessage_0489.Request="";
DYNKernelLogError_0301a.Request="轉換過程中內存不足。";
DYNKernelLogError_0301.Request="錯誤：Dymola 中發生未知的內部錯誤。";
DYNKernelLogError_0301.Diagnostic="建議保存類，然后退出 Dymola";
DYNKernelLogError_0301b.Request="錯誤：無法將文件復制到不存在的目錄 /P1";
DYNKernelLogError_0301b.Diagnostic="請注意，它應指定為 Modelica 字符串（例如，必須使用雙反斜杠）。\n";
DYNKernelLogMessage_0490.Request="置亂 /P1。";
DYNKernelLogMessage_0491.Request="將加密文件 /P1。";
DYNKernelLogMessage_0492.Request="首先置亂文件 /P1。";
DYNKernelLogMessage_0493.Request="加密文件 /P1。";
DYNKernelLogMessage_0494.Request="置亂完成，正在驗證。";
DYNKernelLogMessage_0495.Request="置亂時出錯。請與支持人員聯系。";
DYNKernelLogMessage_0496.Request="正在加密。";
DYNKernelLogMessage_0497.Request="加密完成，可以在 /P1 中找到文件。";
DYNKernelLogMessage_0498.Request="置亂的轉換出現問題，請參閱錯誤消息。";
DYNKernelLogError_0302.Request="錯誤：/P1 行 /P2 列 /P3，“/P4”中存在語法錯誤";
DYNKernelLogMessage_0499.Request="";
DYNKernelLogMessage_0500.Request=" 缺少";
DYNKernelLogMessage_0501.Request="；“/P1”不";
DYNKernelLogMessage_0502.Request=" 在以下范圍內：";
DYNKernelLogMessage_0503.Request=" /P1";
DYNKernelLogMessage_0504.Request=" 在 /P1 中";
DYNKernelLogMessage_0505.Request="";
DYNKernelLogError_0303.Request="/P1 的本地重新定義";
DYNKernelLogMessage_0506.Request="以前聲明的位置";
DYNKernelLogMessage_0507.Request="注意：本地類型 /P1 的擴展";
DYNKernelLogError_0304.Request="錯誤：重復的基類 /P1";
DYNKernelLogMessage_0508.Request="以前聲明的位置";
DYNKernelLogError_0305.Request="/P1 的本地重新定義";
DYNKernelLogMessage_0509.Request="以前聲明的位置";
DYNKernelLogWarning_0137.Request="部件 /P1 名稱與其類型名稱相同";
DYNKernelLogError_0306.Request="錯誤：/P1 的點修飾符和非點修飾符組合";
DYNKernelLogError_0307.Request="錯誤：部件 /P1 的層次修飾符存在問題";
DYNKernelLogError_0308.Request="錯誤：圖形符號前缺少；";
DYNKernelLogError_0309.Request="錯誤：包符號前缺少；";
DYNKernelLogError_0310.Request="錯誤：隱藏文本出現未知錯誤。";
DYNKernelLogMessage_0510.Request=" 在 /P1 中";
DYNKernelLogMessage_0511.Request=" 在 /P1 /P2 中";
DYNKernelLogMessage_0512.Request=".";
DYNKernelLogMessage_0513.Request="將類名稱 /P1 轉換為 /P2";
DYNKernelLogMessage_0514.Request="將名稱 /P1 轉換為 /P2";
DYNKernelLogMessage_0514b.Request="將名稱 /P1 轉換為 /P2。/P3";
DYNKernelLogMessage_0515.Request="轉換假定標量參數，但是參數值是具有 /P1 元素的向量。";
DYNKernelLogMessage_0516.Request="警告：轉換假定標量參數。";
DYNKernelLogMessage_0516.Diagnostic="  可能需要手動轉換。\n";
DYNKernelLogMessage_0517.Request="轉換遇到沖突的修飾符，首選 /P1=/P2，而不是 /P3。";
DYNKernelLogMessage_0518.Request="  在 /P2 中 /P1 的復雜轉換中。結果修飾符為 /P3。";
DYNKernelLogWarning_0138.Request="警告：/P2 中 /P1 的復雜轉換失敗。";
DYNKernelLogMessage_0519.Request="/P2 中 /P1 的復雜轉換得出修飾符 /P3。";
DYNKernelLogMessage_0520.Request="抱歉，元素 /P1 的轉換過于復雜。";
DYNKernelLogMessage_0521.Request="由于 /P2 的連接，正在為 /P1 添加修飾符";
DYNKernelLogMessage_0522.Request="將類名稱 /P1 轉換為 /P2，因為部件已連接";
DYNKernelLogMessage_0523.Request="將類名稱 /P1 轉換為 /P2，因為修飾符";
DYNKernelLogMessage_0524.Request="參數已移動到 /P1 的其他元素。";
DYNKernelLogMessage_0525.Request="無法處理修飾符 /P1 的名稱更改。";
DYNKernelLogMessage_0526.Request="無法處理修飾符 /P1 的名稱更改。";
DYNKernelLogMessage_0527.Request="轉換已更改 /P2 中 /P1 的方程式的修飾符。";
DYNKernelLogMessage_0528.Request="轉換已移除 /P2 中的修飾符 /P1。";
DYNKernelLogMessage_0529.Request="由于修飾符，將標量重新聲明為數組 /P1。";
DYNKernelLogMessage_0531.Request="抱歉，元素 /P1 的轉換過于復雜。";
DYNKernelLogMessage_0532.Request="錯誤：未能打開文件 /P1";
DYNKernelLogMessage_0532.Diagnostic=" 因為 /P2。\n";
DYNKernelLogMessage_0533.Request="保存整個模型發生內部故障";
OverloadedBinaryOp_Resolve_2.Request="沒有過載二進制運算符 /P1 /P2 /P3 的匹配項";
OverloadedBinaryOp_Resolve_3.Request="過載二進制運算符 /P1 /P2 /P3 的多個匹配項";
OverloadedBinaryOp_Resolve_4.Request="與過載二進制運算符 /P1 /P2 /P3 轉換的多個匹配項";
OverloadedConstructor_Resolve_2.Request="沒有 /P1(/P2) 的構造函數的匹配項";
OverloadedExpr_Resolve_1.Request="OverloadedExpr::Resolve 中的類型數據不完整";
OverloadedExpr_Resolve_2.Request="OverloadedExpr::Resolve 中的類型數據不完整";
OverloadedExpr_UncachedGetBasicTypeData.Request="_e0 == 0 在 OverloadedExpr::UncachedGetBasicTypeData 中";
OverloadedExpr_Resolve_3.Request="OverloadedExpr::Resolve 類型 /P1 運算符 /P2 中沒有匹配項";
OverloadedFunction_Resolve_2.Request="OverloadedFunction::Resolve 函數 /P1 中沒有匹配項";
OverloadedRelOp_Variability.Request="表達式生成事件";
OverloadedRelOp_Variability.Diagnostic="  /P1\n無法有條件依賴于 noEvent 表達式。";
DYNKernelLogMessage_0534.Request="El. size   #used   #rsvd   used bytes  rsvd bytes";
DYNKernelLogMessage_0535.Request="  /P1 /P2 /P3 /P4 /P5";
DYNKernelLogMessage_0536.Request="所有使用的池：/P1 個對象 /P2 字節";
DYNKernelLogMessage_0537.Request="所有保留的池：/P1 個對象 /P2 字節";
DYNKernelLogMessage_0538.Request="所有空閑的池：/P1 個對象 /P2 字節";
DYNKernelLogMessage_0539.Request="使用 malloc 的外部池：/P1 字節";
DYNKernelLogMessage_0540.Request="Malloc 統計信息";
DYNKernelLogMessage_0541.Request="  正常：/P2 塊中的 /P1 字節";
DYNKernelLogMessage_0542.Request="  C 運行時：/P2 塊中的 /P1 字節";
DYNKernelLogMessage_0543.Request="無可用空間：   /P2 塊中的 /P1 字節";
DYNKernelLogMessage_0544.Request="忽略客戶端：      /P2 塊中的 /P1 字節";
DYNKernelLogMessage_0545.Request="空：            /P2 塊中的  /P1 字節";
DYNKernelLogMessage_0546.Request="最大分配：/P1 字節";
DYNKernelLogMessage_0547.Request="總分配：/P1 字節";
DYNApplyingInlineForSubtask.Request="子任務“/P1”已使用全局 Dymola 內聯集成設置離散。";
DYNApplyingInlineForSubtask.Diagnostic="  覆蓋映射值 IntegrationMethod./P2。";
DYNDiscretizationForEmbedded.Request="離散周期子任務“/P1”";
DYNDiscretizationForEmbedded.Diagnostic="  方法：  /P2\n  步幅大小：/P3";
DYNSubtaskDiscretizationFailed.Request="具有連續狀態的子任務不允許使用 IntegrationMethod.None。";
DYNUsingSameAsSimulator.Request="IntegrationMethod.SameAsSimulator 應用于連接子任務“/P1”！";
DYNUsingSameAsSimulator.Diagnostic="  覆蓋映射值 IntegrationMethod./P2。";
DYNNoValidEnableMappingAnnotation_01.Request="無法展開變量 /P1 的標注 mapping.apply";
DYNNoValidEnableMappingAnnotation_02.Request="使用默認值 = /P1";
DYNNoValidSampleBasePeriod_01.Request="無法展開變量 /P1 的標注 mapping.task.sampleBasePeriod";
DYNNoValidSampleBasePeriod_02.Request="使用默認值 = /P1";
DYNBadSampleBasePeriod.Request="無法展開標注 mapping.task.sampleBasePeriod";
DYNBadSampleBasePeriod.Diagnostic="/P1\n，屬于變量 /P2。\n使用默認值。";
DYNInconsistentSampleBasePeriod1.Request="任務 /P1 的映射變量的標注 mapping.task.sampleBasePeriod 不一致。";
DYNInconsistentSampleBasePeriod2.Request="它是變量 /P2 的 /P1。";
DYNNoValidSampleOffsetFactor_01.Request="無法展開變量的標注 mapping.subtask.sampleOffsetFactor ";
DYNNoValidSampleOffsetFactor_02.Request="使用默認值 = /P1";
DYNBadSampleOffsetFactor.Request="無法展開標注 mapping.subtask.sampleOffsetFactor";
DYNBadSampleOffsetFactor.Diagnostic="變量 /P2 的 /P1\n。";
DYNInconsistentSampleOffsetFactor1.Request="子任務 /P1 的映射變量的標注 mapping.subtask.sampleOffsetFactor 不一致。";
DYNInconsistentSampleOffsetFactor2.Request="它是變量 /P2 的 /P1。";
DYNNoValidSamplePeriodFactor_01.Request="無法展開變量 /P1 的標注 mapping.subtask.samplePeriodFactor";
DYNNoValidSamplePeriodFactor_02.Request="使用默認值 = /P1";
DYNBadSamplePeriodFactor.Request="無法展開標注 mapping.subtask.samplePeriodFactor";
DYNBadSamplePeriodFactor.Diagnostic="變量 /P2 的 /P1\n。";
DYNInconsistentSamplePeriodFactor1.Request="子任務 /P1 的映射變量的標注 mapping.subtask.samplePeriodFactor 不一致。";
DYNInconsistentSamplePeriodFactor2.Request="它是變量 /P2 的 /P1。";
DYNNoValidPriority_01.Request="無法展開變量 /P1 的標注 mapping.task.priority";
DYNNoValidPriority_02.Request="使用默認值 = /P1";
DYNBadTaskPriority.Request="無法展開標注 mapping.task.priority";
DYNBadTaskPriority.Diagnostic="變量 /P2 的 /P1\n。";
DYNInconsistentTaskPriority1.Request="任務 /P1 的映射變量的標注 mapping.task.priority 不一致。";
DYNInconsistentTaskPriority2.Request="它是變量 /P2 的 /P1。";
DYNNoOnProcessor_01.Request="無法展開變量 /P1 的標注 mapping.task.onProcessor";
DYNNoOnProcessor_02.Request="使用默認值 = /P1";
DYNBadTaskOnProcessor.Request="無法展開標注 mapping.task.onProcessor";
DYNBadTaskOnProcessor.Diagnostic="變量 /P2 的 /P1\n。";
DYNInconsistentTaskOnProcessor1.Request="任務 /P1 的映射變量的標注 mapping.task.onProcessor 不一致。";
DYNInconsistentTaskOnProcessor2.Request="它是變量 /P2 的 /P1。";
DYNNoValidSamplingType_01.Request="無法展開變量 /P1 的標注 mapping.subtask.samplingType";
DYNNoValidSamplingType_02.Request="使用默認值 = /P1";
DYNBadSubtaskSamplingType.Request="無法展開標注 mapping.subtask.samplingType";
DYNBadSubtaskSamplingType.Diagnostic="變量 /P2 的 /P1\n。";
DYNInconsistentSubtaskSamplingType1.Request="子任務 /P1 的映射變量的標注 mapping.subtask.samplingType 不一致。";
DYNInconsistentSubtaskSamplingType2.Request="它是變量 /P2 的 /P1。";
DYNNoValidFloatingPointUnit_01.Request="無法展開變量 /P1 的 floatingPointUnit";
DYNNoValidFloatingPointUnit_02.Request="使用默認值 = /P1";
DYNNoValidRegisterLength_01.Request="無法展開變量 /P1 的 registerLength";
DYNNoValidRegisterLength_02.Request="使用默認值 = /P1";
DYNNoValidTargetName_01.Request="無法展開變量 /P1 的標注 mapping.target.identifier";
DYNNoValidTargetName_02.Request="使用默認值 = /P1";
DYNBadTargetName.Request="無法展開標注 mapping.target.identifier";
DYNBadTargetName.Diagnostic="變量 /P2 的 /P1\n。";
DYNInconsistentTargetName1.Request="任務 /P1 的映射變量的標注 mapping.task.identifier 不一致。";
DYNInconsistentTargetName2.Request="它是變量 /P2 的 /P1。";
DYNNoValidTaskName_01.Request="無法展開變量 /P1 的標注 mapping.task.identifier";
DYNNoValidTaskName_02.Request="使用默認值 = /P1";
DYNNoValidSubtaskName_01.Request="無法展開變量 /P1 的標注 mapping.subtask.identifier";
DYNNoValidSubTaskName_02.Request="使用默認值 = /P1";
DYNNoValidTargetKind_01.Request="無法展開變量 /P1 的標注 mapping.target.kind";
DYNNoValidTargetKind_02.Request="使用默認值 = /P1";
DYNBadTargetKind.Request="無法展開標注 mapping.target.kind";
DYNBadTargetKind.Diagnostic="變量 /P2 的 /P1\n。";
DYNInconsistentTargetKind1.Request="任務 /P1 的映射變量的標注 mapping.target.kind 不一致。";
DYNInconsistentTargetKind2.Request="它是變量 /P2 的 /P1。";
DYNNoValidIntegrationMethod_01.Request="無法展開變量 /P1 的標注 annotation mapping.subtask.integrationMethod";
DYNNoValidIntegrationMethod_02.Request="使用默認值 = /P1";
DYNBadSubtaskIntegrationMethod.Request="無法展開標注 mapping.subtask.integrationMethod";
DYNBadSubtaskIntegrationMethod.Diagnostic="變量 /P2 的 /P1\n。";
DYNInconsistentSubtaskIntegrationMethod1.Request="子任務 /P1 的映射變量的標注 mapping.subtask.integrationMethod 不一致。";
DYNInconsistentSubtaskIntegrationMethod2.Request="它是變量 /P2 的 /P1。";
DYNFailedSupportingParallelDecommposition.Request="不支持并行化。";
DYNBadOutputDecomposition.Request="以下輸出為所指示的不同任務的標注，但其計算未分解。";
DYNBadOutputDecompositionA.Request="  /P1應屬于子任務/P2";
DYNActivatedInVectorWhen.Request="當子句帶有一個以上元素時，激活的子任務在向量化中不支持";
DYNOutputTaskDirectFeeds.Request="子任務/P1從下列輸入到其輸出有直接供給。";
DYNOutputTaskDirectFeedsA.Request="  /P1 來自子任務/P2";
DYNDSPACEInvalid_BasePeriod.Request="指定的基本 dSPACE 樣本周期無效！";
DYNDSPACEInvalid_SamplePeriod_01.Request="任務 '/P1' 的任務周期比 dSPACE 基本周期短！";
DYNDSPACEInvalid_SamplePeriod_02.Request="任務 '/P1' 的任務周期無效！必須為 dSPACE 基本周期的整數倍數。";
DYNFailedSubtaskSorting.Request="子任務排序失敗。";
DYNContactDynasim.Request="請聯系 Dynasim 支持中心。";
DYNMixingClockWarning.Request="方程式中不同的時鐘組合！";
DYNSynchronousOpNonSimpleVarRef.Request="運算符 /P1 的參數必須為變量參考。";
DYNSynchronousOpNonSimpleVarRef.Diagnostic=" 這不是該調用的情況：/P2";
DYNEmbeddedDecoupleNonSimpleVarRef.Request="在方程式中出現";
DYNEmbeddedDecoupleNonSimpleVarRef.Diagnostic="    /P1";
DYNSemiLinearMixed.Request="下面的 semiLinear 方程式具有相同的左手邊變量";
DYNSemiLinearMixed.Diagnostic="/P1";
DYNSemiLinearBadSeq.Request="semiLinear 方程式未組成預期的序列";
DYNSemiLinearBadSeq.Diagnostic="/P1";
DYNSemiLinearManipFailed.Request="semiLinear 方程式操作失敗。";
DYNSemiLinearFailed.Request="支持 semiLinear 失敗。";
DYNStreamConnectorsFailed.Request="支持流連接器失敗。";
DYNFlowAndStream.Request="變量 /P1 非法與前綴流聲明。";
DYNNonRealStream.Request="變量 /P1 與前綴流聲明，但其不是實數類型。";
DYNStreamNoFlow.Request="變量 /P1 與前綴流聲明，但其沒有相關的流連接器。";
DYNStreamMultiFlows.Request="變量 /P1 與前綴流聲明，但其有若干相關的流連接器";
DYNStreamMultiFlows.Diagnostic="/P2";
DYNBadInStreamCall.Request="運算符 inStream 的參數須為流連接器的參考。";
DYNBadInStreamCall.Diagnostic="這不是 /P1 的情況";
DYNBadInStreamCall1.Request="其出現在方程式中";
DYNBadInStreamCall1.Diagnostic="  /P1";
DYNBadInStreamArg.Request="不支持運算符 inStream 建立索引的參數";
DYNBadInStreamArg.Diagnostic="  ";
DYNBadInStreamArg1.Request="其出現在方程式中";
DYNBadInStreamArg1.Diagnostic="  /P1";
DYNBadActualStreamCall.Request="運算符 actualStream 的參數須為流連接器的參考。";
DYNBadActualStreamCall.Diagnostic="這不是 /P1 的情況";
DYNBadActualStreamCall1.Request="其出現在方程式中";
DYNBadActualStreamCall1.Diagnostic="  /P1";
DYNBadActualStreamArg.Request="不支持運算符 actualStream 的建立索引的參數";
DYNBadActualStreamArg.Diagnostic="  ";
DYNBadActualStreamArg1.Request="其出現在方程式中";
DYNBadActualStreamArg1.Diagnostic="  /P1";
DYNStreamConnLogRegA.Request="流方程式";
DYNStreamConnLogRegA.Diagnostic="/P1 被規則化為 \n/P2 和\n/P3";
DYNStreamConnLogRegB.Request="流方程式";
DYNStreamConnLogRegB.Diagnostic="/P1被規則化為/P2";
DYNKernelLogError_SimpleProcess_start.Request="啟動失敗：/P1。安裝正確嗎？";
DYNKernelLogError_SimpleProcess_waitUntilStopped_2.Request="/P1";
DYNKernelLogError_SimpleProcess_waitUntilStopped.Request="/P1 失敗。";
DYNKernelLogError_SimpleXML_xslTransform.Request="無法找到 Saxon jar 文件，/P1 設置正確嗎？";
DYNFailedSynchClockFactor.Request="計算子任務的時鐘系數失敗。";
DYNPreviousNonSimpleVarRef.Request="運算符 /P1 的參數必須為變量參考。";
DYNPreviousNonSimpleVarRef.Diagnostic=" 這不是該調用的情況：/P2";
DYNPreviousNonSimpleVarRefA.Request="在方程式中出現";
DYNPreviousNonSimpleVarRefA.Diagnostic="    /P1";
DYNPreviousNonSimpleVarRefB.Request="在 /P1 的啟動值中出現";
DYNSynchronousOpNonSimpleVarRef.Request="運算符 /P1 的參數必須為變量參考。.";
DYNSynchronousOpNonSimpleVarRef.Diagnostic=" 這不是該調用的情況：/P2";
DYNSynchronousOpNonSimpleVarRefA.Request="在方程式中出現";
DYNSynchronousOpNonSimpleVarRefA.Diagnostic="    /P1";
DYNSynchronousOpNonSimpleVarRefB.Request="在 /P1 的啟動值中出現";
DYNDifferentiatedPrevious.Request="變量 /P1 區分顯示且作為之前的參數。";
DYNMixedDifferentiatedAndPrevious.Request="連續時間和離散時間的混合分區。";
DYNMixedDifferentiatedAndPreviousA.Request="其包括以下節點";
DYNMixedDifferentiatedAndPreviousB.Request="節點 /P1";
DYNMixedDifferentiatedAndPreviousB.Diagnostic="未知：/P2方程式：/P3";
DYNTimeAndPrevious.Request="同步的離散部分不能直接參考時間，但是其必須取樣時間，樣本（時間）。";
DYNTimeAndPreviousA.Request="離散部分包括以下節點";
DYNTimeAndPreviousB.Request="塊/P1";
DYNTimeAndPreviousB.Diagnostic="未知：/P2方程式：/P3";
DYNBadOutputDecomposition.Request="以下輸出為所指示的不同任務的標注，但其計算未分解。";
DYNBadOutputDecompositionA.Request="  /P1 應屬于子任務 /P2";
DYNActivatedInVectorWhen.Request="當子句帶有一個以上元素時，激活的子任務在向量化中不支持";
DYNFailedSubClockSorting.Request="子時鐘某方面的排序失敗。";
DYNContactDynasim.Request="請聯系 Dynasim 支持中心。";
DYNMixingClockWarning.Request="方程式中不同的時鐘組合！";
DYNSynchronousOpDataFailed.Request="操作運算符失敗";
DYNSynchronousOpDataFailed.Diagnostic=" /P1 用于方程式 /P2 中";
DYNSynchronousArgNonPos.Request="/P2 的參數 /P1";
DYNSynchronousArgNonPos.Diagnostic="在方程式中，\n/P3\n必須為正的。";
DYNSynchronousArgNonlit.Request="無法計算 /P2 的參數 /P1";
DYNSynchronousArgNonlit.Diagnostic="在方程式 /P3 中";
DYNSampleDiscrete.Request="連續/離散規格不一致";
DYNSampleDiscrete1.Request="樣本的第一個參數必須在連續時間部分內";
DYNSampleDiscrete1.Diagnostic="/P1";
DYNSampleDiscrete2.Request="然而，方程式 /P1 要求參數在離散部分內。";
DYNSampleToContinuous.Request="連續/離散規格不一致";
DYNSampleToContinuous1.Request="方程式中的樣本運算符";
DYNSampleToContinuous1.Diagnostic="/P1 要求方程式和其他非樣本變量在離散部分內。";
DYNSampleToContinuous2.Request="然而，方程式 /P1 要求相同的參數在連續時間內。";
DYNSampleBadPeriod.Request="周期規格不一致";
DYNSampleBadPeriod1.Request="方程式中的樣本運算符";
DYNSampleBadPeriod1.Diagnostic="/P1 要求方程式并與周期 /P2 一起取樣。";
DYNSampleBadPeriod2.Request="然而，方程式";
DYNSampleBadPeriod2.Diagnostic="/P1 要求樣本周期為 /P2。";
DYNHoldToDiscrete.Request="連續/離散規格不一致";
DYNHoldToDiscrete1.Request="方程式中的控制運算符 ";
DYNHoldToDiscrete1.Diagnostic="/P1 要求方程式和其他非控制變量在連續時間內。";
DYNHoldToDiscrete2.Request="然而，方程式 /P1 要求相同的變量在離散的部分內。";
DYNTimeHoldArg.Request="連續/離散規格不一致";
DYNTimeHoldArg1.Request="第一個控制變量不能為時間";
DYNTimeHoldArg1.Diagnostic="/P1";
DYNContinuousHoldArg.Request="連續/離散規格不一致";
DYNContinuousHoldArg1.Request="第一個控制變量必須在離散的部分內";
DYNContinuousHoldArg1.Diagnostic="/P1";
DYNContinuousHoldArg2.Request="然而，方程式 /P1 要求變量在連續的時間部分內。";
DYNTimeSubSuperSampleArg.Request="連續/離散規格不一致";
DYNTimeSubSuperSampledArg1.Request="/P1 的第一個變量不能為時間";
DYNTimeSubSuperSampledArg1.Diagnostic="/P2";
DYNContinuousSubSuperSampleArg.Request="連續/離散規格不一致";
DYNContinuousSubSuperSampleArg1.Request="/P1 的第一個變量必須在離散的部分內";
DYNContinuousSubSuperSampleArg1.Diagnostic="/P2";
DYNSSubSuperSampleToContinuous.Request="連續/離散規格不一致";
DYNSubSuperSampleToContinuous1.Request="方程式中的 /P1 運算符 ";
DYNSubSuperSampleToContinuous1.Diagnostic="/P1 要求方程式和其他變量在離散的時間內。";
DYNSubSuperSampleToContinuous2.Request="然而，方程式 /P1 要求相同的變量在連續的部分內。";
DYNSSubSampleNonIntegerFactor.Request="推導出的非整數下取樣系數 /P1。";
DYNSSubSampleNonIntegerFactor1.Request="來源被推導出周期 /P1 來自 ";
DYNSSubSampleNonIntegerFactor1.Diagnostic="/P2";
DYNSSubSampleNonIntegerFactor2.Request="方程式被推導出周期 /P1 來自 ";
DYNSSubSampleNonIntegerFactor2.Diagnostic="/P2";
DYNSSubSampleNonIntegerFactor3.Request="其要求 /P1 的非整數下取樣系數。";
DYNSubSampleFactorInconsistent.Request="下取樣系數 /P1 不一致。";
DYNSubSampleFactorInconsistent1.Request="來源被推導出周期 /P1 來自 ";
DYNSubSampleFactorInconsistent1.Diagnostic="/P2";
DYNSubSampleFactorInconsistent2.Request="方程式被推導出周期 /P1 來自 ";
DYNSubSampleFactorInconsistent2.Diagnostic="/P2";
DYNSubSampleFactorInconsistent3.Request="其與調用 /P1 指定的系數不同。";
DYNSuperSampleNonIntegerFactor.Request="推導出的非整數上取樣系數 /P1。";
DYNSuperSampleNonIntegerFactor1.Request="來源被推導出周期 /P1 來自 ";
DYNSuperSampleNonIntegerFactor1.Diagnostic="/P2";
DYNSuperSampleNonIntegerFactor2.Request="方程式被推導出周期 /P1 來自 ";
DYNSuperSampleNonIntegerFactor2.Diagnostic="/P2";
DYNSuperSampleNonIntegerFactor3.Request="其要求 /P1 的非整數上取樣系數。";
DYNSuperSampleFactorInconsistent.Request="上取樣系數 /P1 不一致。";
DYNSuperSampleFactorInconsistent1.Request="來源被推導出周期 /P1 來自 ";
DYNSuperSampleFactorInconsistent1.Diagnostic="/P2";
DYNSuperSampleFactorInconsistent2.Request="方程式被推導出周期 /P1 來自 ";
DYNSuperSampleFactorInconsistent2.Diagnostic="/P2";
DYNSuperSampleFactorInconsistent3.Request="其與調用 /P1 指定的系數不同。";
DYNContinuousSubSuperSampleArg2.Request="然而，方程式 /P1 要求變量在連續的時間部分內。";
DYNDelaySamplePeriodInconsistent.Request="取樣周期 /P1 不一致。";
DYNDelaySamplePeriodInconsistent1.Request="來源被推導出周期 /P1 來自 ";
DYNDelaySamplePeriodInconsistent1.Diagnostic="/P2";
DYNDelaySamplePeriodInconsistent2.Request="方程式被推導出周期 /P1 來自 ";
DYNDelaySamplePeriodInconsistent2.Diagnostic="/P2";
DYNSampleBadPhase.Request="階段規格不一致。";
DYNSampleBadPhase1.Request="方程式中的樣本運算符";
DYNSampleBadPhase1.Diagnostic="/P1 要求方程式并與階段 /P2 一起取樣。";
DYNSampleBadPhase2.Request="然而，方程式";
DYNSampleBadPhase2.Diagnostic="/P1 要求取樣階段為 /P2。";
DYNSubSamplePhaseInconsistent.Request="階段 /P1 不一致。";
DYNSubSamplePhaseInconsistent1.Request="來源被推導出階段 /P1 來自 ";
DYNSubSamplePhaseInconsistent1.Diagnostic="/P2";
DYNSubSampleFhaseInconsistent2.Request="方程式被推導出階段 /P1 來自 ";
DYNSubSampleFhaseInconsistent2.Diagnostic="/P2";
DYNSubSamplePhaseInconsistent4.Request="其給出 /P1 的階段轉換。";
DYNSubSamplePhaseInconsistent5.Request="其與調用 /P1 指定的系數不同。";
DYNDelaySamplePhaseInconsistent.Request="階段 /P1 不一致。";
DYNDelaySamplePhaseInconsistent1.Request="來源被推導出階段 /P1 來自 ";
DYNDelaySamplePhaseInconsistent1.Diagnostic="/P2";
DYNDelaySamplePhaseInconsistent2.Request="方程式被推導出階段 /P1 來自 ";
DYNDelaySamplePhaseInconsistent2.Diagnostic="/P2";
DYNDelaySamplePhaseInconsistent3.Request="其未給出調用 /P1 指定的階段差別。";
DYNSynch4DecompositionFailed.Request="連續時間和離散部分的分解失敗。";
DYNSynch4DecompositionFailed1.Request="/P1 的參數";
DYNSynch4DecompositionFailed1.Diagnostic=" 而且發現方程式 /P2 屬于相同的分區。";
DYNFailedSynchClockMixed.Request="連續時間部分和離散部分未分解";
DYNFailedSynchClockPhase.Request="未能計算子任務的時鐘階段。";
DYNFailedToExpand.Request="未能擴展 /P1。";
DYNKernelLogMessage_0548.Request="發現 /P1 /P2";
DYNKernelLogMessage_0549.Request="發現 /P1 /P2";
DYNKernelLogMessage_0551.Request="引入 /P1 共用子表達式并重新使用 /P2 變量";
DYNKernelLogMessage_0551.Diagnostic="",
"全部用于 /P3 表達式中。\n";
DYNKernelLogMessage_0552.Request="其中，/P1 為記錄元素，/P2 實數 /P3 整數 /P4 布爾型";
DYNKernelLogMessage_0553.Request="其中，/P1 為實數 /P2 整數 /P3 布爾型。";
DYNKernelLogMessage_0554.Request="而且 /P1 為連續的，/P2 離散 /P3 參數表達式。";
DYNBadRelEvent.Request="表達式生成事件";
DYNBadRelEvent.Diagnostic="  /P1\n無法有條件地依賴于非事件表達式。";
DYNWhenCondNotDiscrete.Request="時間條件必須為離散表達式";
DYNWhenCondNotDiscrete.Diagnostic="  /P1";
DYNWhenLHSNotDiscrete.Request="時間子句的左手邊應為離散表達式";
DYNWhenLHSNotDiscrete.Diagnostic="  /P1";
DYNAssToLowerVariability1.Request="嘗試用更高的可變性指派 /P1 的值";
DYNAssToLowerVariability1.Diagnostic="  /P2";
DYNAssToLowerVariability2.Request="嘗試在由更高的可變性控制的環內指派 /P1";
DYNAssToLowerVariability2.Diagnostic="  /P2";
DYNContEquNonReal.Request="非實數方程式為連續時間是不合法的";
DYNContEquNonReal.Diagnostic="  /P1";
DYNReinitOutsideWhen.Request="發現 reinit 不在時間子句內";
DYNReinitOutsideWhen.Diagnostic="  /P1";
DYNContPreOutsideWhen.Request="在時間子句外不允許使用 pre 作為連續時間變量";
DYNContPreOutsideWhen.Diagnostic="  /P1";
DYNVariabilityError.Request="檢測到錯誤";
DYNVariabilityError.Diagnostic="/P1";
DYNVariabiliCheckFailed.Request="可變性檢查失敗。";
DYNDefEquTooHighVariability.Request="定義方程式的可變性";
DYNDefEquTooHighVariability.Diagnostic="/P1\n 比聲明的變量可變性高。";
DYNWhenContCond.Request="時間子句不能為連續條件";
DYNWhenContCond.Diagnostic="  /P1";
DYNContactDynasim.Request="請聯系支持中心。";
DYNDeducedTypeTitle.Request="推導出的類型";
DYNDeducedTypeA.Request="  /P1/P2 /P3/P4 = /P5;";
DYNDeducedTypeB.Request="  /P1/P2 /P3";
DYNDeducedTypeC.Request="  /P1/P2 /P3/P4;";
DYNDeducedTypeC.Diagnostic="// 3951 校正官方漢化  /P5";
DYNDeducedTypeD.Request="  /P1/P2 /P3;";
DYNDeducedTypeD.Diagnostic="// 3951 校正官方漢化  /P4";
DYNNewLine.Request="     ";
DYNDeducedFunctionTypeTitle.Request="輸入和輸出推導出的函數類型";
DYNDeducedFunctionTypeA.Request="函數 /P1";
DYNDeducedFunctionTypeB.Request="  /P1 /P2 /P3/P4;";
DYNDeducedFunctionTypeC.Request="結束 /P1；";
DYNUnitMeasureMultDef.Request="單位的多個定義：/P1";
DYNUnitMeasureSignNoNumber.Request="符號 /P1 在單位表達式中沒有數字";
DYNUnitMeasureSignNoNumber.Diagnostic="  /P2";
DYNUnitMeasureTooHighANumber.Request="/P1 在單位表達式中的數字太高";
DYNUnitMeasureTooHighANumber.Diagnostic="  /P2";
DYNUnitMeasureIncomp2.Request="哪里";
DYNUnitMeasureIncompInEqu.Request="不兼容的單位";
DYNUnitMeasureIncompInEqu.Diagnostic="  /P1";
DYNUnitMeasureIncompInExpr.Request="不兼容的單位";
DYNUnitMeasureIncompInExpr.Diagnostic="  /P1";
DYNUnitMeasureIncomp.Request="不兼容的單位。";
DYNUnitMeasureIncomp1.Request="零件";
DYNUnitMeasureIncomp1.Diagnostic="  /P1 有單位 /P2";
DYNUnitMeasureVarContext.Request="該單位串顯示在變量 /P1 的聲明中。";
DYNUnitMeasureBadSymbol.Request="無法解碼單位符號 /P1";
DYNUnitMeasureBadSymbol.Diagnostic="顯示在單位串 /P2 中";
DYNUnitMeasureBadUparrow.Request="在單位串中發現 \"^\"：/P1";
DYNUnitMeasureBadUparrow1.Request="字符 \"^\" 不能用在單位串中，";
DYNUnitMeasureBadUparrow1.Diagnostic="例如，不能寫 \"m^3\"，但可寫 \"m3\"";
DYNUnitMeasureBadStar.Request="在單位串中發現 \"*\"：/P1";
DYNUnitMeasureBadStar1.Request="不能使用字符 \"*\"。使用 \".\"。";
DYNUnitMeasureBadStar1.Diagnostic="例如，不能寫 \"N*m\"，但可寫 \"N.m\"";
DYNUnitMeasureBadToken.Request="在單位串中發現非法令牌 /P1：/P2";
DYNUnitMeasureBadDiv.Request="在單位串中發現 \"/\" 在非法位置";
DYNUnitMeasureBadDiv.Diagnostic="/P1";
DYNUnitMeasureBadDiv1.Request="例如，不能寫 \"J/m/K\"，但可寫 \"J/(m.K)\"";
DYNUnitMeasureIllegalStartSpace.Request="在單位串的開頭發現非法間距：/P1";
DYNUnitMeasureIllegalSpace.Request="在 /P1 后發現非法間距";
DYNUnitMeasureIllegalSpace.Diagnostic="在單位串中：/P2";
DYNUnitMeasureSyntaxError.Request="在 /P1 發現語法錯誤";
DYNUnitMeasureSyntaxError.Diagnostic="在單位串中：/P2";
DYNUnitMeasureAlgContext.Request="報告的單位問題顯示在算法指派中";
DYNUnitMeasureAlgContext.Diagnostic="  /P1";
DYNUnitMeasureEquContext.Request="報告的單位問題顯示在方程式中";
DYNUnitMeasureEquContext.Diagnostic="  /P1";
DYNUnitMeasureIncompleteCheck.Request="未完成的 /P1 單位檢查";
DYNUnitMeasureDeducedUnitsStart1.Request="  /P1（單位 = /P2） // 3951 校正官方漢化 來自其開始值。";
DYNUnitMeasureDeducedUnitsStart2.Request="  /P1（單位 = /P2）// 3951 校正官方漢化 來自 /P3 的開始值";
DYNUnitMeasureDeducedUnitsEqu.Request="  /P1（單位 = /P2）";
DYNUnitMeasureDeducedUnitsEqu.Diagnostic="    // 3951 校正官方漢化 來自方程式 /P3";
DYNUnitMeasureDeducedUnit.Request="  /P1（單位 = /P2）";
DYNUnitMeasureDeducedUnitsElements.Request="  /P1   /P2";
DYNUnitMeasureDeducedUnits.Request="推導出的以下變量的單位";
DYNUnitMeasureNonPure.Request="非純正 SI 單位：變量 /P1";
DYNUnitMeasureNonPure.Diagnostic="具有單位 \"/P2\"\n，意即 \"/P3\" 不是純正的 SI 單位（不能帶前綴和縮放）。";
DYNUnitMeasureBindingContext.Request="報告的單位問題顯示在變量綁定方程式中";
DYNUnitMeasureBindingContext.Diagnostic="  /P1";
DYNUnitMeasureBindingContextStart.Request="報告的單位問題顯示在變量的開始值中";
DYNUnitMeasureBindingContextStart.Diagnostic="  /P1";
DYNKernelLogWarning_0139.Request="在 /P2 中發現未知元素 /P1";
DYNKernelLogWarning_0140.Request="表達式 /P1 和值 /P2 可能轉換不正確";
DYNKernelLogWarning_0141.Request="表達式 /P1 和值 /P2 可能轉換不正確";
DYNKernelLogWarning_0142.Request="表達式 /P1 和值 /P2 可能轉換不正確";
DYNKernelLogWarning_0143.Request="表達式 /P1 和值 /P2 可能轉換不正確";
DYNKernelLogWarning_0144.Request="表達式 /P1 和值 /P2 可能轉換不正確";
DYNKernelLogWarning_0145.Request="表達式 /P1 和值 /P2 可能轉換不正確";
DYNKernelLogWarning_0146.Request="表達式 /P1 和值 /P2 可能轉換不正確";
DYNKernelLogWarning_0147.Request="警告：程序包 /P1 包含帶有舊 Modelica 協議的圖形動畫";
DYNLinkMissing.Request="在 /P1 至 /P2 中丟失的參考";
ShowModelFilters_1.Request="/P1 /P2";
DYNKernelLogWarning_0001.Request="警告：不允許絕對鏈接意味著無鏈接至：/P1";
DYNKernelLogError_0311.Request="錯誤：/P1";
DYNKernelLogError_0311.Diagnostic="/P2";
DYNKernelLogMessage_0562.Request="";
DYNKernelLogMessage_0563.Request="輸入 ComponentPickObject:：選取 () 級別 /P1";
DYNKernelLogMessage_0564.Request="  單擊 /P1 (/P2) 類型 /P3";
DYNKernelLogMessage_0565.Request="  設置 last_picked_connector = /P1";
DYNKernelLogMessage_0566.Request="  設置 last_picked_component = /P1";
DYNKernelLogMessage_0567.Request="  清除之前選取的（/P1 對象）";
DYNKernelLogMessage_0568.Request="  選取 /P1";
DYNKernelLogMessage_0569.Request="  之前選取的 /P1";
DYNKernelLogMessage_0570.Request="退出 ComponentPickObject:：選取 () 級別 /P1";
DYN_Clipboard_CopyUnknown.Request="未知圖形對象。";
DYN_Clipboard_CopyDuplicate.Request="圖形部件實例 /P1 在剪貼板中已經存在。";
DYN_Clipboard_PasteNonExist2.Request="類別 /P1 不存在。";
DYN_Clipboard_PasteReadOnly.Request="無法粘貼到只讀類別 /P1。";
DYN_Clipboard_PasteInnerOuter.Request="部件 /P1 為內部或外部且部件名稱已被使用；粘貼將給出新名稱且很可能不按照預期工作。";
DYN_Clipboard_PasteIcon.Request="可能只粘貼純圖形信息到圖標。";
DYN_Clipboard_MoveReadOnly.Request="無法從只讀類別 /P1 移動。";
DYN_Clipboard_MoveOne.Request="在移動一個選擇到子系統時，該選擇必須存在，有來源且為純圖形。";
DYNKernelLogMessage_0029.Request="必須設置環境變量 NLPSOLVERS 以使用 MOPS（如，通過使用 mops_directory）。";
DYNKernelLogMessage_0030.Request="錯誤：要使用優化，您需要優化許可選項。";
DYNKernelLogMessageErrorMops.Request="加載 mops 出錯：/P1";
DYNKernelLogMessage_0032.Request="必須設置環境變量 NLPSOLVERS 才能使用 MOPS。";
DYNKernelLogMessage_0033.Request="錯誤：要使用優化，您需要優化許可選項。";
DYNKernelLogMessage_0034.Request="加載 mops 出錯：/P1";
DYNKernelLogMessage_0035.Request="加載 mops 出錯：/P1";
DYNKernelLogMessage_0036.Request="錯誤：要使用優化，您需要優化許可選項。";
DYNKernelLogMessage_0037.Request="加載 mops 出錯：/P1";
DYNKernelLogMessage_0038.Request="必須設置環境變量 NLPSOLVERS 才能使用 MOPS。";
DYNKernelLogError_0036.Request="以下文檔路徑不存在";
DYNKernelLogMessage_0039.Request="錯誤：要使用優化，您需要優化許可選項。";
DYNKernelLogMessage_0040.Request="加載 mops 出錯：/P1";
DYNKernelLogMessage_0041.Request="成功優化";
DYNKernelLogMessage_0042.Request="計算過多。";
DYNKernelLogMessage_0043.Request="迭代過多。";
DYNKernelLogMessage_0044.Request="無活動的變量";
DYNKernelLogMessage_0045.Request="不允許限制和相等";
DYNKernelLogMessage_0046.Request="不允許不等式";
DYNKernelLogMessage_0047.Request="不允許方程式";
DYNKernelLogError_0037.Request="錯誤：函數 /P1 無法優化。";
DYNKernelLogError_0038.Request="錯誤：無法找到函數 /P1 進行優化。";
DYNKernelLogError_SimpleFileUtil_removeIfExists.Request="無法移除現有 /P1。它是寫保護嗎？";
DYNKernelLogError_SimpleFileUtil_move.Request="未能移動 /P1 至 /P2";
DYNKernelLogError_SimpleFileUtil_getResourceAsString.Request="未能從 /P1 獲得資源";
DYNKernelLogError_SimpleFileUtil_getResourceAsFile_1.Request="無法打開臨時文件";
DYNKernelLogError_SimpleFileUtil_getResourceAsFile_2.Request="未能打開文件 /P1";
DYNKernelLogError_0312.Request="錯誤：無法找到 /P1";
DYNKernelLogError_Func01.Request="無法處理外部函數 /P1，";
DYNKernelLogError_Func01.Diagnostic="可能需要計算常數，這對于一個調用是不可能的。\n";
DYN_KERNEL_LOG_ERROR_2000.Request="找不到類別 /P1。";
DYN_KERNEL_LOG_ERROR_2001.Request="無法修改只讀類別 /P1。";
DYN_KERNEL_LOG_ERROR_OnlyTop.Request="只能修改頂級類別的這個屬性而不是 /P1。";
DYN_KERNEL_LOG_ERROR_2002.Request="新名稱不是有效的標識符。";
DYN_KERNEL_LOG_ERROR_2002Name.Request="新程序包名稱無效。";
DYN_KERNEL_LOG_ERROR_2021.Request="找不到程序包。";
DYN_KERNEL_LOG_ERROR_2022.Request="無法重命名類別，因為目標地址已經存在。";
DYN_KERNEL_LOG_ERROR_2022Copy.Request="無法復制類別，因為目標地址已經存在。";
DYN_KERNEL_LOG_ERROR_2001Expression.Request="類別 /P1 的動畫表達式無效。";
DYN_KERNEL_LOG_ERROR_2003.Request="找不到標注。";
DYN_KERNEL_LOG_ERROR_SetAttributesShort.Request="該類別無法轉變為短類別 /P1";
DYN_KERNEL_LOG_ERROR_SetAttributesConstrained.Request="只能指定由 /P1 限制在與類別 /P2 的可替換組合。";
DYN_KERNEL_LOG_ERROR_2026.Request="類別 /P1 被隱藏。";
DYN_KERNEL_LOG_ERROR_2027.Request="平面 Modelica 僅適用于模型和塊。";
DYN_KERNEL_LOG_ERROR_2029.Request="在進行平面 Modelica 描述時檢測到錯誤。請檢查 /P1 并修正錯誤。";
DYN_KERNEL_LOG_ERROR_2028.Request="Modelica 文本過大，無法顯示。";
DYN_KERNEL_LOG_ERROR_2030.Request="通過平面 Modelica 打開結果文件失敗。";
DYNKernelLogError_0314B.Request="無法以文本形式添加本地類別 /P1，因為它已經存在";
DYNKernelLogError_0314A.Request="文本編輯被限制：你無法添加，如本地類別。請分別創建";
DYNKernelLogError_0314.Request="此實例的父實例未鎖定。";
DYN_KERNEL_LOG_ERROR_2016.Request="無法在程序包 /P1 中對部件實例化。";
DYN_KERNEL_LOG_ERROR_2025.Request="廢除部件類別：/P1";
DYN_KERNEL_LOG_ERROR_2020.Request="無法實例化部件：/P1";
DYN_KERNEL_LOG_ERROR_2017.Request="因為內部錯誤，無法實例化部件。";
DYN_KERNEL_LOG_ERROR_2018.Request="無法命名部件：/P1";
DYN_KERNEL_LOG_ERROR_2006.Request="無法實例化程序包中的連接。";
DYN_KERNEL_LOG_ERROR_2007.Request="無啟動連接器。";
DYN_KERNEL_LOG_ERROR_2008.Request="無結束連接器。";
DYN_KERNEL_LOG_ERROR_2009.Request="壞連接：連接到自身。";
DYN_KERNEL_LOG_ERROR_2010.Request="復制連接。/P1 和 /P2 之間的連接已經存在。";
DYN_KERNEL_LOG_ERROR_2011.Request="第一個連接器的附加數據不是合法的標識符。";
DYN_KERNEL_LOG_ERROR_2012.Request="第二個連接器的附加數據不是合法的標識符。";
DYN_KERNEL_LOG_ERROR_2013.Request="無法實例化連接：/P1";
DYN_KERNEL_LOG_ERROR_2031.Request="connectorSizing 參數或修飾符必須為零，才能創建一個內部的一元連接。";
DYN_KERNEL_LOG_ERROR_2026b.Request="connectorSizing 參數或修飾符的字面值必須為整數。";
DYN_KERNEL_LOG_ERROR_2014.Request="未指定部件。";
DYN_KERNEL_LOG_ERROR_1002.Request="找不到部件 /P1。";
DYN_KERNEL_LOG_ERROR_2015.Request="不能移除只讀部件 \n/P1。";
DYN_KERNEL_LOG_ERROR_2004.Request="無連接。";
DYN_KERNEL_LOG_ERROR_2005.Request="未能找到或移除連接。";
DYN_KERNEL_LOG_ERROR_1005.Request="新名稱 /P1 不是有效標識符。";
DYN_KERNEL_LOG_ERROR_1000.Request="無法找到父級類別 /P1。";
DYN_KERNEL_LOG_ERROR_1001.Request="無法修改只讀父級 /P1。";
DYN_KERNEL_LOG_ERROR_1004.Request="另一稱為 /P1 的部件已經在類別中存在。";
DYN_KERNEL_LOG_ERROR_1003.Request="無法修改只讀部件 /P1。";
DYN_KERNEL_LOG_ERROR_1006.Request="無法使部件具有與其類型相同的名稱：/P1";
DYN_KERNEL_LOG_ERROR_1007.Request="找不到標注。";
DYN_KERNEL_LOG_ERROR_1008.Request="無法更改來自程序包中的常數的類型。";
DYN_KERNEL_LOG_ERROR_1010.Request="無法解析子腳本  /P1。";
DYN_KERNEL_LOG_ERROR_1011.Request="找不到類別/P1。";
DYN_KERNEL_LOG_ERROR_1012.Request="無法修改只讀類別 /P1。";
DYN_KERNEL_LOG_ERROR_1013.Request="無法創建短類別名稱 /P1。";
DYN_KERNEL_LOG_ERROR_1014.Request="\"/P1\" 不是有效的修飾符。";
DYN_KERNEL_LOG_ERROR_2019.Request="找不到擴展類別：/P1。";
DYNKernelLog_RawMessage.Request="/P1";
DYNErrorInvalidCompilerPath.Request="錯誤：編譯器路徑無效。";
DYNErrorLoadingDymosimDLL.Request="錯誤：在加載模擬器 DLL 時發生錯誤。";
DYN_Clipboard_PasteNonExist1.Request="類別不存在。";
